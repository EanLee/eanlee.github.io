<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Docker | 使用 Docker 建置 ASP.NET Webapi 的 Image - 伊恩的開發狂想</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7903108559996033" crossorigin=anonymous></script><meta name=description content="在使用 Docker 封裝應用程式時，有時因為程式需要使用一些機敏性資料，例如連線字串及憑證資料等，就需要額外處理。在接下來的內文中，以 ASP.NET Webapi 為例，簡述如何在確保使用容器技術的同時，又能保護機密性資料不被外人所知道。"><meta property="og:title" content="Docker | 使用 Docker 建置 ASP.NET Webapi 的 Image"><meta property="og:description" content="在使用 Docker 封裝應用程式時，有時因為程式需要使用一些機敏性資料，例如連線字串及憑證資料等，就需要額外處理。在接下來的內文中，以 ASP.NET Webapi 為例，簡述如何在確保使用容器技術的同時，又能保護機密性資料不被外人所知道。"><meta property="og:type" content="article"><meta property="og:url" content="https://eandev.com/post/container/aspnet-webapi-containerized/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-26T14:18:53+08:00"><meta property="article:modified_time" content="2023-11-11T20:53:23+08:00"><meta itemprop=name content="Docker | 使用 Docker 建置 ASP.NET Webapi 的 Image"><meta itemprop=description content="在使用 Docker 封裝應用程式時，有時因為程式需要使用一些機敏性資料，例如連線字串及憑證資料等，就需要額外處理。在接下來的內文中，以 ASP.NET Webapi 為例，簡述如何在確保使用容器技術的同時，又能保護機密性資料不被外人所知道。"><meta itemprop=datePublished content="2023-02-26T14:18:53+08:00"><meta itemprop=dateModified content="2023-11-11T20:53:23+08:00"><meta itemprop=wordCount content="964"><meta itemprop=keywords content="ASP.NET,Docker,Docker-Network,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker | 使用 Docker 建置 ASP.NET Webapi 的 Image"><meta name=twitter:description content="在使用 Docker 封裝應用程式時，有時因為程式需要使用一些機敏性資料，例如連線字串及憑證資料等，就需要額外處理。在接下來的內文中，以 ASP.NET Webapi 為例，簡述如何在確保使用容器技術的同時，又能保護機密性資料不被外人所知道。"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=/css/style.min.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-4HXSCXTZKZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4HXSCXTZKZ",{anonymize_ip:!1})}</script><link href=/css/syntax.min.css rel=stylesheet><link href=/css/copy-to-clipboard.min.css rel=stylesheet></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class="logo logo--mixed"><a class=logo__link href=/ title=伊恩的開發狂想 rel=home><div class="logo__item logo__imagebox"><img class=logo__img alt=logo src=/img/placeholder.png></div><div class="logo__item logo__text"><div class=logo__title>伊恩的開發狂想</div><div class=logo__tagline>在知識大海中漂流的小船，不停追尋屬於自己的秘寶。專注於 .NET、雲端技術、系統架構、開發技巧的道、法、術。</div></div></a></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Docker | 使用 Docker 建置 ASP.NET Webapi 的 Image</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>伊恩</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-02-26T14:18:53+08:00>2023-02-26</time>
<time class=meta__text datetime=2023-11-11T20:53:23+08:00>(Last Modified: 2023-11-11)</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/container/ rel=category>container</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#dockerfile-簡介>Dockerfile 簡介</a><ul><li><a href=#single-stage-build>Single-Stage Build</a></li><li><a href=#multi-stage-build>Multi-Stage Build</a></li></ul></li><li><a href=#機敏資料的處理>機敏資料的處理</a><ul><li><a href=#資料庫的連線字串>資料庫的連線字串</a></li></ul></li><li><a href=#faq>FAQ</a><ul><li><a href=#為何-webapi-container-無法連線本機另一個-container-的資料庫>為何 Webapi Container 無法連線本機另一個 Container 的資料庫？</a></li></ul></li><li><a href=#延伸閱讀>延伸閱讀</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>想要使用 Docker 技術將 ASP.NET Web API 應用程式打包成 image 時，需要針對機敏性資料進行特別的處理，以確保這些機密性資料不會外流。</p><p>在本文中，將簡單介紹 Dockerfile 的建置方式，以及如何提供連線字串給 Container 內的應用程式使用。雖然內文只介紹連線字串的部份，但是憑證的處理方式，也是類似的作法。</p><blockquote><p>🔖 長話短說 🔖</p><ul><li>在使用 Docker 封裝應用程式時，有時需要使用一些機敏性資料，需要額外處理，例如連線字串及憑證資料等。</li><li>Container 的所有設定，都可以透過 <code>docker inspect</code> 指令查看到，所以傳遞機敏性資料，必須要加密或透過其他方式。</li><li>機敏資料的傳遞，可以透過 <code>環境變數</code>、<code>命令列參數</code>與 <code>mount/volume</code> 的方式。</li><li>Docker Image 建立後，可以使用 <code>docker scan</code> 指令，進行掃描，確認是否有安全性問題。</li></ul></blockquote><p>實作環境</p><ul><li>Windows 10</li><li>.NET 7.0</li><li>Docker Engine 20.10.8</li></ul><h2 id=dockerfile-簡介>Dockerfile 簡介</h2><p>雖然在 <a href=https://eandev.com/post/series/build-automated-deploy/docker-operate/>Docker 操作簡介</a> 已經有提過，不過還是簡單回顧一下。</p><h3 id=single-stage-build>Single-Stage Build</h3><p>關於 Docker 建置 Image 時，最簡單的方式就是在 Dockerfile 內一個步驟完成所有的設定，這種方式稱為 <code>Single-Stage Build</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/sdk:7.0</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /src</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;demo/demo.csproj&#34;</span>, <span style=color:#e6db74>&#34;demo/&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet restore <span style=color:#e6db74>&#34;demo/demo.csproj&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /src/demo</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet build <span style=color:#e6db74>&#34;demo.csproj&#34;</span> -c Release -o /app/build<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet publish <span style=color:#e6db74>&#34;demo.csproj&#34;</span> -c Release -o /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 443</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;dotnet&#34;</span>, <span style=color:#e6db74>&#34;demo.dll&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>簡單說明一下指令的意義</p><ul><li><code>FROM</code> 使用的 base Image</li><li><code>WORKDIR</code> 目前 Image 內所在的位置</li><li><code>COPY</code> 把外部資料複制到 Image 內的指定位置</li><li><code>RUN</code> 執行指定的指令</li><li><code>EXPOSE</code> 指定 Image 內的服務埠</li><li><code>ENTRYPOINT</code> 指定 Image 內的執行指令</li></ul><p>但要特別注意，若是在 <code>Single-Stage Build</code> 中，直接將程式碼進行建置、打裝的方式，會將所有的步驟所使用的工具、中繼檔、程式碼等等，都包含在 Image 內。</p><p>導致 Image 內部存在不必要的檔案、多餘資料，除了檔案過大外，還可能造成資料的外洩。</p><p>當然，我們也可以建置過程中，加入指令刪除建置過程中，所使用的程式碼與中繼檔，也僅能確保刪除的項目不會被他人看到，至於過程中使用的工具等，可能還是遺留在 Image 內。</p><p>Docker 的 <a href=https://docs.docker.com/build/building/multi-stage/>官方文件</a>，也建議使用 <code>Multi-Stage Build</code> 的方式，來建置 Image。除了可以減少 Image 的大小外，也可以確保 Image 內的資料，不會被外洩。</p><h3 id=multi-stage-build>Multi-Stage Build</h3><p>在 Visual studio 建立 .NET 專案時，若有勾選 support Docker 的選項。在建立專案的同時，一併建立 <code>Dockerfile</code> 的檔案，其內容的編排，就是使用 <code>Multi-stage</code> 的方式。</p><p>在這個 Dockerfile 內的描述，會分成四個階段來進行建置。</p><ul><li>首先，建立運行發佈程式所需要的 Base Image。</li><li>再來，建立建置環境用的影像檔，裡面包含.NET SDK 與 程式碼，並確認程式碼可以正常建置。</li><li>第三步，將第二步建置過的程式碼，打包成發佈版本。</li><li>最後，將發佈版本的程式，放入運行環境的 Base Image 內。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#75715e># 建立一個執行程式的基礎模板</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/aspnet:7.0 AS base</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 443</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 使用 .NET SDK 的 Image, 並程式碼複製到容器內，並執行建置</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/sdk:7.0 AS build</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /src</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;demo/demo.csproj&#34;</span>, <span style=color:#e6db74>&#34;demo/&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet restore <span style=color:#e6db74>&#34;demo/demo.csproj&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> &#34;/src/demo&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet build <span style=color:#e6db74>&#34;demo.csproj&#34;</span> -c Release -o /app/build<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 使用上一步建立的 Image, 進行發佈版本的建置</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> build AS publish</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> dotnet publish <span style=color:#e6db74>&#34;demo.csproj&#34;</span> -c Release -o /app/publish<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 將最後建置的程式，放置到基礎的 Image 內，並設定執行的指令</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> base AS final</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>publish /app/publish .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;dotnet&#34;</span>, <span style=color:#e6db74>&#34;demo.dll&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>若要確認每一個階段的 Image 內容，可以使用 <code>docker image history</code> 指令，來查看。</p><p>也可以使用 <code>docker scan</code> 指令，來進行掃描，確認是否有安全性的問題。</p><h2 id=機敏資料的處理>機敏資料的處理</h2><p>在專案中，可能會有一些機敏資料，例如資料庫的連線字串、憑證資料等等。大伙都知道，這些資料不應該直接放置在程式碼內。相同的，也不應該放置在 Image 內。</p><p>此外，在實際的應用中，可能需要使用憑證來進行身份驗證或資料加密。雖然後續文章只介紹連線字串的部份，但是憑證的處理方式，也是類似的作法。</p><p>在 Docker 中，可以運用 <code>mount/volume</code> 與 <code>環境變數</code> 方式，提供憑證、相關檔案、密碼，給 Container 使用。</p><p>藉由掛載方式，將憑證檔案掛載到 container 內，讓應用程式可以存取這些檔案，並且進行相關的操作。此外，也可以將憑證密碼以環境變數的形式傳入 Container 中，讓應用程式可以透過這些環境變數來存取憑證資料。</p><p>值得注意的是，掛載憑證資料的方式需要額外注意資料的安全性。我們可以使用加密的方式來保護憑證資料的安全性，以防止資料被未經授權的人員存取。</p><h3 id=資料庫的連線字串>資料庫的連線字串</h3><p>若 ASP.NET Webapi 已經建置為 Docker Image，可以使用<code>環境變數</code>、<code>命令列</code>、<code>掛載文件檔</code> 的方式，來傳遞資料庫的連線資訊。</p><p>提醒一下，<code>Container</code> 建立後，是可以用 <code>docker inspect</code> 查看 Container 的相關設定，無論是用那種方式，機敏資料最好還是要進行加密。</p><p>先把已知的各種做法的差異，整理列表如下</p><table><thead><tr><th>作法類型</th><th>啟動 Container 的動作</th><th>Dockfile 設定</th><th>程式碼調整</th></tr></thead><tbody><tr><td>環境變數</td><td>使用 <code>-e</code> 指定資料庫相關資訊</td><td><code>ENV</code></td><td>組成連線字串、加解密</td></tr><tr><td>環境變數</td><td>使用 <code>-e</code> 指定連線字串</td><td><code>ENV</code></td><td>加解密</td></tr><tr><td>命令列</td><td>使用 <code>--</code> 傳入命令列參數</td><td></td><td>取得 Args 資料、加解密</td></tr><tr><td>掛載文件檔</td><td>使用 <code>-v</code> 掛載資料夾路徑或 volume</td><td><code>VOLUME</code></td><td>讀取特定位置的檔案</td></tr></tbody></table><h4 id=作法一環境變數>作法一、環境變數</h4><h5 id=自組連線字串>自組連線字串</h5><p>在 Dockerfile 內，建立多組的環境變數，如 <code>Host</code>、<code>Port</code>、<code>Database</code>、<code>User</code>、<code>Password</code> 等。並在程式碼中，使用環境變數的方式，自行組合為連線字串。</p><p>簡單說明一下，實作的方式。在程式碼的部份，連線字串的取得方式，改為由環境變數自行組合而成。</p><p>實務上，在 User 與 Password 的部份，建議環境變數的資料，使用加密後的密文，避免明文的方式傳遞。在組合連線字串前再解密，以避免資料外洩。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 機敏資料的解密。</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用自行實作的 Decrypt 方法來解密</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> user = Decrypt(Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;DB_USER&#34;</span>));
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> password = Decrypt(Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;DB_PASSWORD&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 以 postgresql 的連線字串 為例</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> connectionString = <span style=color:#66d9ef>string</span>.Format(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Host={0};Port={1};Database={2};Username={3};Password={4};Pooling=true;&#34;</span>,
</span></span><span style=display:flex><span>    Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;DB_HOST&#34;</span>),
</span></span><span style=display:flex><span>    Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;DB_PORT&#34;</span>),
</span></span><span style=display:flex><span>    Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;DB_NAME&#34;</span>),
</span></span><span style=display:flex><span>    user,
</span></span><span style=display:flex><span>    password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddDbContext&lt;LabContext&gt;(options =&gt; options.UseNpgsql(connectionString));
</span></span></code></pre></div><p>接著，調整 Dockerfile ，增加環境變數。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/aspnet:7.0 AS base</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 設定 DB 相關的環境變數，這邊先給予預設值</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> DB_HOST<span style=color:#f92672>=</span><span style=color:#ae81ff>127</span>.0.0.1<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> DB_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ENV</span> DB_NAME<span style=color:#f92672>=</span>postgres
</span></span><span style=display:flex><span><span style=color:#66d9ef>ENV</span> DB_USER<span style=color:#f92672>=</span>postgres
</span></span><span style=display:flex><span><span style=color:#66d9ef>ENV</span> DB_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 443</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>// 略 ...<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>在完成上述的調整後，就可以使用 <code>docker run</code> 的方式，啟動容器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -e DB_HOST<span style=color:#f92672>=</span>127.0.0.1 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           -e DB_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>5432</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           -e DB_NAME<span style=color:#f92672>=</span>postgres <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           -e DB_USER<span style=color:#f92672>={</span>加密後的使用者名稱<span style=color:#f92672>}</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           -e DB_PASSWORD<span style=color:#f92672>={</span>加密後的密碼<span style=color:#f92672>}</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           -d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           -p 5000:80 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>           --name webapi lab/webapi
</span></span></code></pre></div><h5 id=加密後的連線字串>加密後的連線字串</h5><p>若是覺得傳入多個環境變數過於麻煩，也可以採用直接傳入連線字串的方式。</p><p>這邊，我們將連線字串加密，使用環境變數的方式，傳遞加密後的字串，這樣就可以避免直接將連線字串放置在程式碼內。</p><p>要注意的是，加密後的連線字串，無法直接使用，需要在程式碼中，進行解密。至於連線字串的加解密方式，網路上已經有很多範例，這邊就不再贅述。例如：<a href=https://blog.darkthread.net/blog/encrypt-ef-connstring/>為EF連線字串加密的簡單範例-黑暗執行緒</a>。</p><p>基本上，Dockerfile 的調整方式，與作法一相同，只是在環境變數的設定上，改為加密後的連線字串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/aspnet:7.0 AS base</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 加入環境變數</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> ConnectionStrings<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 443</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>// 略 ...<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 連線字串的解密。</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用自行實作的 Decrypt 方法來解密</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> connectionString = Decrypt(Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;ConnectionStrings&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.Services.AddDbContext&lt;LabContext&gt;(options =&gt; options.UseNpgsql(connectionString));
</span></span></code></pre></div><p>在完成上述的調整後，就可以使用 <code>docker run</code> 的方式，啟動 Container。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d -p 5000:80 --name webapi -e ConnectionStrings<span style=color:#f92672>={</span>加密後的連線字串<span style=color:#f92672>}</span> lab/webapi
</span></span></code></pre></div><h4 id=作法二command-argument>作法二、Command Argument</h4><p>除了使用環境變數的方式， 也可以在不調整 dockerfile 的前提下，Command Argument 傳遞加密後連線字串。</p><p>在這作個簡單 Demo 範例，先新增一個 ASP.NET Core Webapi 專案，並在 Program.cs 中，加入以下的程式碼。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>var</span> list = args.ToList();
</span></span><span style=display:flex><span>Log.Information(list.Count &gt; <span style=color:#ae81ff>0</span> ? <span style=color:#66d9ef>string</span>.Join(<span style=color:#e6db74>&#34; &#34;</span>, list) : <span style=color:#e6db74>&#34;No arguments&#34;</span>);
</span></span></code></pre></div><p>直接使用 Dockerfile 建置 Image，並運行 Container。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 建置 Image</span>
</span></span><span style=display:flex><span>docker build . -f Dockerfile -t lab/webapi-args:latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 運行 Container</span>
</span></span><span style=display:flex><span>docker run -p 5000:80 --name webapi lab/webapi-args --ConnectionStrings<span style=color:#f92672>=</span>agnongw8gan99s<span style=color:#f92672>==</span>
</span></span></code></pre></div><p><figure><center><img src=images/docker-multi-stage-build.png alt="Multi-Stage 建置 Image 的訊息"><figcaption>Multi-Stage 建置 Image 的訊息</figcaption></center></figure></p><p><figure><center><img src=images/docker-run-args.png alt="傳入的 Argument 確實的被程式取得"><figcaption>傳入的 Argument 確實的被程式取得</figcaption></center></figure></p><h4 id=作法三掛載文件檔>作法三、掛載文件檔</h4><p>一般而言，當我們使用 EF Core 來建立資料庫的連線時，通常會將連線資訊存放在 appsettings.json 檔案中。</p><p>同樣地，我們可以沿用這種方式，將連線資訊先存放在另一個 JSON 檔案中，並將這個檔案放在指定的主機位置或 Docker Volume 內。</p><p>雖然在範例中，直接取得連線字串的明文。但是，正式環境，最好是加密後的連線字串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> mcr.microsoft.com/dotnet/aspnet:7.0 AS base</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 加入 Volume</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>VOLUME</span><span style=color:#e6db74> /app/data</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 443</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>// 略 ...<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 宣告存放連線字串的 connect.json 檔案</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> configuration = <span style=color:#66d9ef>new</span> ConfigurationBuilder()
</span></span><span style=display:flex><span>                   .SetBasePath(Directory.GetCurrentDirectory())
</span></span><span style=display:flex><span>                   .AddJsonFile(<span style=color:#e6db74>&#34;appsettings.json&#34;</span>)
</span></span><span style=display:flex><span>                   .AddJsonFile(<span style=color:#e6db74>&#34;connect.json&#34;</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>                   .Build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 讀取連線字串</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> connectionString = builder.Configuration.GetConnectionString(<span style=color:#e6db74>&#34;Lab&#34;</span>);
</span></span><span style=display:flex><span>builder.Services.AddDbContext&lt;LabContext&gt;(options =&gt; options.UseNpgsql(connectionString));
</span></span></code></pre></div><p>若是直接把 connect.json 放在實體主機的指定位置，可以使用以下的方式，將檔案掛載到容器內的指定位置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 假設 connect.json 放在 /home/user/connect.json</span>
</span></span><span style=display:flex><span>docker run -d -p 5000:80 --name webapi -v /home/user/:/app/data lab/webapi
</span></span></code></pre></div><p>若是使用 Docker Volume 的方式，將檔案掛載到容器內，可以使用以下的方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 建立 Volume</span>
</span></span><span style=display:flex><span>docker volume create <span style=color:#f92672>{</span>connect-volume<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 將 connect.json 放入 Volume</span>
</span></span><span style=display:flex><span>docker run -d -v <span style=color:#f92672>{</span>connect-volume<span style=color:#f92672>}</span>:/data -v <span style=color:#f92672>{</span>connect.json 所在位置<span style=color:#f92672>}</span>:/src/ alpine sh -c <span style=color:#e6db74>&#34;cp /src/connect.json /data&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 運行 Container</span>
</span></span><span style=display:flex><span>docker run -d -p 5000:80 --name webapi -v <span style=color:#f92672>{</span>connect-volume<span style=color:#f92672>}</span>:/app/data lab/webapi
</span></span></code></pre></div><p>完成後，的應用程式就可以直接使用 connect.json 檔案內的連線字串，來連線資料庫。</p><p>光說不練假把式，我們使用下方的幾行指令來快速驗證，檔案確實有被放入 <code>VOLUME</code> 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 進入檔案所的資料夾</span>
</span></span><span style=display:flex><span>cd c:/Codes/Lab/Demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 建立 Volume</span>
</span></span><span style=display:flex><span>$ docker volume create lab-volume
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 確認 Volume 是否建立成功</span>
</span></span><span style=display:flex><span>$ docker volume ls --filter <span style=color:#e6db74>&#34;name=lab&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 將 appsettings.json 放入 Volume</span>
</span></span><span style=display:flex><span><span style=color:#75715e># %cd% 代表目前所在的資料夾, 若是使用 PowerShell 則是 $pwd</span>
</span></span><span style=display:flex><span>$ docker run -v lab-volume:/data -v %cd%:/src alpine sh -c <span style=color:#e6db74>&#34;cp /src/appsettings.json /data&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 啟動 Container 並進入</span>
</span></span><span style=display:flex><span>$ docker run -it -v lab-volume:/data alpine
</span></span></code></pre></div><p><figure><center><img src=images/docker-volume-add-file.png alt="快速驗證檔案加入 Volume 的流程"><figcaption>快速驗證檔案加入 Volume 的流程</figcaption></center></figure></p><h2 id=faq>FAQ</h2><h3 id=為何-webapi-container-無法連線本機另一個-container-的資料庫>為何 Webapi Container 無法連線本機另一個 Container 的資料庫？</h3><p>原因如同 <a href=../DevOps/GitLab%20CI%20%E5%AF%A6%E4%BD%9C%E8%A8%98%E9%8C%84(1)%20-%20%E4%BD%BF%E7%94%A8%20Docker%20%E5%9C%A8%E5%90%8C%E5%8F%B0%E4%B8%BB%E6%A9%9F%E9%81%8B%E8%A1%8C%20GitLab%20%E8%88%87%20GitLab-Runner.md>GitLab CI 實作記錄(1) - 使用 Docker 在同台主機運行 GitLab 與 GitLab-Runner</a> 中提到的 Docker Network 的觀念問題。</p><p>在同一台主機上，啟動 Container 卻不指定 Network 的情況下，會使用名為 <code>bridge</code> 的預設 Network。</p><p>而加預設 Network 內的 Container ，會被自動分配一個網段為 <code>172.17.0.0/16</code> 的 IP 位置，此時要連線到其他 Container，必須要知道對方的 IP 位置。</p><p>這是因為預設 Network 不支援 Docker 內的 DNS 功能，因此無法透過 Container 的名稱來連線。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d -e host<span style=color:#f92672>=</span>localhost -p 5001:80 lab/webapi
</span></span></code></pre></div><p>上述指令中，指定 Webapi 的 container 的環境變數 <code>host</code> 為 <code>localhost</code>，但實際上，對於 Webapi 的 container 來說，<code>localhost</code> 是指是自己的 IP 位置，而非使用者的主機。更不用說資料庫的 container 了。</p><p>當 Webapi 的 container 指定連線的 Host 為 <code>localhost</code> 時，實際上是連線到 Webapi container 自己，而非資料庫的 container。</p><p>對此，有兩種解決方式：</p><h4 id=解法一使用資料庫的-container-的-ip-位置>解法一、使用資料庫的 container 的 IP 位置</h4><ul><li>使用資料庫的 container 的 IP 位置，而非 <code>localhost</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 查詢 Webapi 的 container 的 IP 位置</span>
</span></span><span style=display:flex><span>docker inspect -f <span style=color:#e6db74>&#34;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#34;</span> <span style=color:#f92672>{</span>db_container_name<span style=color:#f92672>}</span>
</span></span></code></pre></div><p><figure><center><img src=images/docker-inspect-network-ip.png alt="使用 docker inspect 查詢 container 的 IP address"><figcaption>使用 docker inspect 查詢 container 的 IP address</figcaption></center></figure></p><h4 id=解法二新增-network-並使用-docker-內的-dns-功能>解法二、新增 Network 並使用 Docker 內的 DNS 功能</h4><p>將 Webapi 的 container 與資料庫的 container 都加入到同一個 Network 內，並指定相同的網段，這樣兩個 Container 就可以互相連線了。</p><p>只要手動增加一個類型為 <code>Bridge</code> 的 Network，它就會自動支援 Docker 內的 DNS 功能。</p><p>然後先把資料庫的 Container 切換到新的 Network 內，再啟動 Webapi 的 Container，就可以使用資料庫的 Container 的名稱來連線了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 建立 Network</span>
</span></span><span style=display:flex><span>docker network create --driver bridge <span style=color:#f92672>{</span>network_name<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 將資料庫的 Container 切換到新的 Network 內</span>
</span></span><span style=display:flex><span>docker network connect <span style=color:#f92672>{</span>network_name<span style=color:#f92672>}</span> <span style=color:#f92672>{</span>db_container_name<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 啟動 Webapi 的 Container</span>
</span></span><span style=display:flex><span>docker run -d --name -e host<span style=color:#f92672>={</span>db_container_name<span style=color:#f92672>}</span> -e database<span style=color:#f92672>=</span>demo -e user_id<span style=color:#f92672>=</span>test -e password<span style=color:#f92672>=</span>test -p 5001:80 lab/webapi --network <span style=color:#f92672>{</span>network_name<span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=延伸閱讀>延伸閱讀</h2><p>▶ 站內文章</p><ul><li><a href=https://eandev.com/post/series/build-automated-deploy/docker-operate/>Docker 操作簡介</a></li><li><a href=https://eandev.com/post/develop/dotnet-ef-postgresql-dbcontext/>使用 dotnet-ef 建立 PostgreSQL 的 DBContext</a></li><li><a href=https://eandev.com/post/develop/dotnet-ef-sqlserver/>使用 dotnet-ef 建立 SQL Server on Docker 的 DBContext</a></li><li><a href=https://eandev.com/post/container/docker-postgresql-initialization-scripts/>建立 PostgreSQL 的 container 時，同時完成資料庫的初始化</a></li></ul><p>▶ 站外文章</p><ul><li><a href=https://www.connectionstrings.com/>ConnectionStrings.com</a></li><li><a href=https://blog.darkthread.net/blog/encrypt-ef-connstring/>為EF連線字串加密的簡單範例-黑暗執行緒</a></li></ul></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><a class=tag href=/tags/asp.net/ rel=tag>ASP.NET</a>
<a class=tag href=/tags/docker/ rel=tag>Docker</a>
<a class=tag href=/tags/docker-network/ rel=tag>Docker-Network</a></ul></div></footer><hr><div><p>文章內容均為個人學習記錄、心得與認知，若任何謬誤或建議，歡迎直接留言討論，一同成長。</p></div><iframe class=LikeCoin src="https://button.like.co/in/embed/wosilee/button?referrer=https%3a%2f%2feandev.com%2fpost%2fcontainer%2faspnet-webapi-containerized%2f" height=200 width=100% frameborder=0></iframe>
<script src=/js/copy-code-clipboard.min.js></script></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/container/docker-postgresql-initialization-scripts/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Docker | 建立 PostgreSQL 的 container 時，同時完成資料庫的初始化</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/develop/http-response-status-unexpected-note/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>ASP.NET Core | API 回應 HTTP Status 非預期的原因筆記</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//eanblog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 伊恩軟體技術學習與分享.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div></body></html>