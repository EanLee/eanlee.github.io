<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>淺談 Pattern | 生產者與消費者模型 - 伊恩的開發狂想</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7903108559996033" crossorigin=anonymous></script><meta name=description content="佇列常見用於生產者與消費者模型之中，作為兩者之間的緩沖區。將雙方的直接關係進行解耦，並減少雙方效率不均的問題。"><meta property="og:title" content="淺談 Pattern | 生產者與消費者模型"><meta property="og:description" content="佇列常見用於生產者與消費者模型之中，作為兩者之間的緩沖區。將雙方的直接關係進行解耦，並減少雙方效率不均的問題。"><meta property="og:type" content="article"><meta property="og:url" content="https://eandev.com/post/pattern/producer-consumers/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-02T07:58:59+00:00"><meta property="article:modified_time" content="2023-02-02T07:58:59+00:00"><meta itemprop=name content="淺談 Pattern | 生產者與消費者模型"><meta itemprop=description content="佇列常見用於生產者與消費者模型之中，作為兩者之間的緩沖區。將雙方的直接關係進行解耦，並減少雙方效率不均的問題。"><meta itemprop=datePublished content="2023-02-02T07:58:59+00:00"><meta itemprop=dateModified content="2023-02-02T07:58:59+00:00"><meta itemprop=wordCount content="182"><meta itemprop=keywords content="系統架構,"><meta name=twitter:card content="summary"><meta name=twitter:title content="淺談 Pattern | 生產者與消費者模型"><meta name=twitter:description content="佇列常見用於生產者與消費者模型之中，作為兩者之間的緩沖區。將雙方的直接關係進行解耦，並減少雙方效率不均的問題。"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=/css/style.min.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-4HXSCXTZKZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4HXSCXTZKZ",{anonymize_ip:!1})}</script><link href=/css/syntax.min.css rel=stylesheet><link href=/css/copy-to-clipboard.min.css rel=stylesheet></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class="logo logo--mixed"><a class=logo__link href=/ title=伊恩的開發狂想 rel=home><div class="logo__item logo__imagebox"><img class=logo__img alt=logo src=/img/placeholder.png></div><div class="logo__item logo__text"><div class=logo__title>伊恩的開發狂想</div><div class=logo__tagline>在知識大海中漂流的小船，不停追尋屬於自己的秘寶。專注於 .NET、雲端技術、系統架構、開發技巧的道、法、術。</div></div></a></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>淺談 Pattern | 生產者與消費者模型</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>伊恩</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-02-02T07:58:59Z>2023-02-02</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/pattern/ rel=category>Pattern</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#生產者與消費者模型>生產者與消費者模型</a></li><li><a href=#併發程式的三大特性-原子性有序性可見性>併發程式的三大特性: 原子性、有序性、可見性</a><ul><li><a href=#原子性-atomic>原子性 <em>Atomic</em></a></li><li><a href=#有序性-ordering>有序性 <em>Ordering</em></a></li><li><a href=#可見性-visibility>可見性 <em>Visibility</em></a></li></ul></li><li><a href=#延伸閱讀>延伸閱讀</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>佇列常見用於生產者與消費者模型之中，作為兩者之間的緩沖區。將雙方的直接關係進行解耦，並減少雙方效率不均的問題。</p><p>而在併發的架構下，必須使用鎖定機制與同步機制，確保佇列中的之資源被正確的存取，避免重覆使用或錯誤覆寫的情況。</p><h2 id=生產者與消費者模型>生產者與消費者模型</h2><p>依慣例，在說明<strong>生產者與消費者模型(producer-consumers pattern)</strong> 之前，先用一個現實的情境來舉例。</p><pre tabindex=0><code class=language-Plan data-lang=Plan>A 公司推出新的 3C 產品，預計會有兩、三波的搶購熱潮。

所以它找了三間代工廠，幫它預先生產了五萬組商品，放在 A 公司的集貨倉庫之中。後續持續生產三萬組。
如它預期，一上巿果然引起搶購熱潮，庫存在幾天內，就將商品售完。消費者因為沒有現貨，只能等待到貨。

A 公司評估銷售後，這情況，決定新增一間代工廠，追加兩萬組商品。
那知好景不長，B 公司推出殺手級的商品，大部份旳消費者轉向購買 B 公司的商品。
A 公司只能將緊急中止新代工廠的訂單，待原本代工廠完成原本的訂單後，停止生產。而己經生產的商品，持續放在倉庫中，等待消費者來購買。
</code></pre><p>在上面的故事中，我們看到三個角色。這三個角色動作的時間點與作用均不相同。</p><ul><li>代工廠：在銷售前的預生產；銷售中的持續生產；最後完成訂單後，停止生產。</li><li>集貨倉庫：商品的存放區。</li><li>消費者：銷售後的購買行為。</li></ul><p><figure><center><img src=images/producer-customer-pattern.png alt="生產者-消費者 模型"><figcaption>生產者-消費者 模型</figcaption></center></figure></p><p>其中，代工廠作為<strong>生產者</strong>，負責產生資源(商品)。集貨倉庫可視為 Queue，負責資源的暫存緩衝與資源調派。消費者，就負責把資源取走、使用。</p><p>在實例中，可以觀察到以下的特性。</p><ul><li><p>解耦</p><p>代工廠與消費者中間，透過集貨倉庫，將兩端隔離。不會發生消費者直接衝到代工廠內，大喊我要商品，快給我。或是代工廠衝到消費者面對，大喊給我買。</p><p>透過集貨倉庫，代工廠不會知道有那些消費者會來購買商品。相同的，消費者也不知道商品是那些代工廠所生產的。</p><p>A 公司決定更換代工廠，對消費者完全沒影響。消費者的身分，由個人購買更換為公司行號大量購買，對代工廠也沒有影響。<strong>因為兩者而言，它們所聚焦的重點在於商品本身，而非其他對象</strong>。</p></li><li><p>並發</p><p>以代工廠的角度，代工廠將生產出來的商品放到集貨倉庫，完全不需考慮商品的銷售情況。A 公司可以依商品的銷售情況，增減代工廠的數量。</p><p>以消費者的角度：如果商品本身很受歡迎，有購買意願的消費者數量就會增加。反之，如果沒有購買意願，消費者的數量就會減少。而不需理會代工廠產生的商品數量。</p></li><li><p>速率不均</p><p>在上面的例子中，因為商品生產的速度比較慢，所在代工廠在銷售之前，就預先生產五萬商品。但是因為消費者購買速率遠大於生產速度，造成售完的情況。</p><p>雖然，A 公司預估預產商品錯誤有誤，讓商品出現售完的情況。偶後，因為滯銷的情況，讓後面生商出來的商品只能存放於倉庫，等待慢慢銷售。</p><p>但換個角度，正是因為有集貨倉庫，讓商品可以預生產與滯銷的週轉空間。</p></li></ul><p>將上面提到的三個特性，試著以軟體系統的角度解讀。</p><ul><li><p>解耦</p><p>若將生產者與消費者分別視為兩個不同的 A、B 模組。</p><p>當發生 A 模組直接調用 B 模組的方法，兩者之間就建立起耦合關係。若將來 B 模組的方法變更，就可能影響到 A。</p><p>利用 Queue 將兩者隔離，讓兩者依賴於 Queue，A、B 模組之間沒有直接依賴，解決其耦合關係。</p></li><li><p>並發</p><p>系統可以依據最重要資源數量，動態決定是增加產生資源的生產者數量，還是減少處理資源的消費者數量。</p></li><li><p>速率不均</p><p>有時資料的產生，可能是一瞬間突然湧進，利用 Queue 的緩衝特性，讓來不及處理的資料可以先暫存下來，等後面產生資料的速度慢下來後，可以處理完成。</p></li></ul><p>彙整 Queue 的使用情境，可以得到以下幾點資訊。</p><ul><li>速率不對等：產生資料的速度與處理資料的速度不同。</li><li>避免高耦合：不希望產生資料的模組與處理資料的模組直接相互存取，避免高耦合。</li><li>並發性處理：同時可以多線程的產生資料，或是處理資料。</li><li>資源的調配：當 Queue 塞滿資源時，要讓生產端得知；不存在任何資料時，則需處理端知道。</li></ul><p>因為這種需要處理的問題，一再反覆出現。當其具有規則性旳部份，統整為一個模型，就是<strong>生產者與消費者模型(producer-consumers pattern)</strong></p><p>面對並發、速率不均的因素，如何有效管理資源放入或取出的正確性，就變得十分的重要。為此，對 Queue 有以下的要求。</p><ul><li>當 Queue 己填滿資源，就要阻擋生產者持續產生資源，避免持續填入資源。</li><li>當 Queue 內部清空時，也要阻擋消費者繼續取得資源。</li></ul><p>當符合兩點特性的 Queue，稱為阻塞佇列 (BlockQueue) 。</p><p>為確保 Queue 內的共用資源的正確性，就必需對存取 Queue 的對象有所管制，避免同時多個對象對同一資源操作。因此需要是互斥鎖、非排他鎖等鎖定機制。</p><p>不管是互斥鎖、Semaphore、Mutex、WaitHandle 的那一種作法，其主要的目的，都是為了確保<strong>多執行緒爭相存取共用資源時，共用資源內容的正確性。</strong></p><p>在 <code>.NET Core</code> 之中，己經針對生產者消費者模型，設計 <a href=https://docs.microsoft.com/zh-tw/dotnet/api/system.collections.concurrent.iproducerconsumercollection-1>IProducerConsumerCollection</a> 介面。而 <code>BlockCollection</code>、<code>ConcurrentQueue</code> 均基於 <code>IProducerConsumerCollection</code> 的實作，提供安全執行緒集合適用的封鎖和界限容量，</p><h2 id=併發程式的三大特性-原子性有序性可見性>併發程式的三大特性: 原子性、有序性、可見性</h2><p>在設計並發性的系統中，許多前輩與神人，整理出三個原則。分為<strong>原子性</strong>、<strong>有序性</strong>、<strong>可見性</strong>。</p><h3 id=原子性-atomic>原子性 <em>Atomic</em></h3><p>在以前，原子被認為為是最小的粒子，無法在再分割。雖然現在已經推翻這個概念，但還是習慣使用這個名詞。</p><p>以筆者的解讀，原子性指的就是<strong>一個流程或操作之中，無法被外部因素影響，而造成中斷。</strong> 對具有原子性的操作而言，只有兩種可能。</p><ul><li>操作內所有的動作、變更都順利完成。</li><li>操作失敗，內部的動作、變更全部不存在。</li></ul><p>像 <code>Lock</code> 機制，Lock 內的區塊，就視為一個不可分割的執行個體。在執行期間，不會被任何外部因素打斷或影響。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>lock</span>(obj)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 此區塊可視為一個不可分割的整體</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>原子性的區塊大，可以確保更多的操作，但相對的，可能減低系統的效能。區塊小，可能無法確保操作。還是要依據需求，進行評估原子性區塊的範圍。</p><h3 id=有序性-ordering>有序性 <em>Ordering</em></h3><p>使用 Queue 就是因為有著 FIFO 這種有順序的操作方式。相同的，多個執行緒對共用資源操作，可以依據對共用資源存取的請求順序，依序操作。</p><p>筆者的理解，有序性，就是會依先後進入的順序，進行操作或存取。<code>Lock</code> 、<code>Mutex</code> 就是屬於這種的。</p><p>這時，再把前面的圖回顧一下。</p><p><figure><center><img src=images/Lock.png alt=Lock><figcaption>Lock</figcaption></center></figure></p><p>Producer 1、Producer 2、Customer 1 三者前後請求對 Queue 的操作，而 Queue 處理與回應的順序，也是與請求順序相同。這就是有序性。</p><h3 id=可見性-visibility>可見性 <em>Visibility</em></h3><p>今天，我去超商買走最後一瓶飲料，其他顧客要買時，就會發現飲料沒了。相同的情境，套到系統內，當共用資源被某一個執行緒修改，其他存取共用資源的執行緒也會發現資料的變更，這就是可見性。</p><p>在運用原子性的操作後，所有取存共用資源的執行緒，所得到的，都是變更後的最新的資訊，</p><p>如果系統為效能的考量，採用了快取的機制。而快取資料，一般是固定間隔才會更新資料，所以存取快取而來的資料，不一定是最新的。</p><p>這種情況，就是為了效能而犧牲了部份的可見性。</p><h2 id=延伸閱讀>延伸閱讀</h2><p>▶ 生產者消費者模式</p><ul><li><a href=https://blog.csdn.net/canot/article/details/51541920>生產者/消費者模式(阻塞隊列) 一個經典的並發模型</a></li><li><a href=https://columns.chicken-house.net/2008/10/18/%E7%94%9F%E7%94%A2%E8%80%85-vs-%E6%B6%88%E8%B2%BB%E8%80%85-blockqueue-%E5%AF%A6%E4%BD%9C/>生產者 vs 消費者 - BlockQueue 實作</a></li><li><a href=https://www.dotnetcurry.com/dotnetcore/1509/async-dotnetcore-pattern>Asynchronous Producer Consumer Pattern in .NET (C#)</a></li><li><a href=https://www.cnblogs.com/tjudzj/p/4454490.html>BlockingQueue（阻塞隊列）詳解</a></li></ul><p>▶ 併發程式的三大特性</p><ul><li><a href=https://juejin.im/post/5d8814975188253f6c75e179>解決原子性問題？腦海中有這個模型就可以了</a></li><li><a href=https://ithelp.ithome.com.tw/users/20121042/ironman/2792>分散式系統 - 在分散的世界中保持一致</a></li></ul></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><a class=tag href=/tags/%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/ rel=tag>系統架構</a></ul></div></footer><hr><div><p>文章內容均為個人學習記錄、心得與認知，若任何謬誤或建議，歡迎直接留言討論，一同成長。</p></div><iframe class=LikeCoin src="https://button.like.co/in/embed/wosilee/button?referrer=https%3a%2f%2feandev.com%2fpost%2fpattern%2fproducer-consumers%2f" height=200 width=100% frameborder=0></iframe>
<script src=/js/copy-code-clipboard.min.js></script></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/pattern/producer-consumers/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>淺談 Pattern | 生產者與消費者模型</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/security/using-iis-create-and-complete-csr/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>使用 IIS 進行 SSL 憑證的申請與更新的步驟與注意事項</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//eanblog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 伊恩軟體技術學習與分享.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div></body></html>