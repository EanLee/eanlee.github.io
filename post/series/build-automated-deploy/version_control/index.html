<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>程式碼版控 - 觀念與 Git 簡述 - 伊恩的開發狂想</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7903108559996033" crossorigin=anonymous></script><meta name=description content="初步簡單的介紹版控的觀念，並介紹常用的 Git 指令與 Git Flow"><meta property="og:title" content="程式碼版控 - 觀念與 Git 簡述"><meta property="og:description" content="初步簡單的介紹版控的觀念，並介紹常用的 Git 指令與 Git Flow"><meta property="og:type" content="article"><meta property="og:url" content="https://eandev.com/post/series/build-automated-deploy/version_control/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-07-29T10:14:10+08:00"><meta property="article:modified_time" content="2023-01-12T07:14:12+00:00"><meta itemprop=name content="程式碼版控 - 觀念與 Git 簡述"><meta itemprop=description content="初步簡單的介紹版控的觀念，並介紹常用的 Git 指令與 Git Flow"><meta itemprop=datePublished content="2022-07-29T10:14:10+08:00"><meta itemprop=dateModified content="2023-01-12T07:14:12+00:00"><meta itemprop=wordCount content="646"><meta itemprop=keywords content="版控,"><meta name=twitter:card content="summary"><meta name=twitter:title content="程式碼版控 - 觀念與 Git 簡述"><meta name=twitter:description content="初步簡單的介紹版控的觀念，並介紹常用的 Git 指令與 Git Flow"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.min.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-4HXSCXTZKZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4HXSCXTZKZ",{anonymize_ip:!1})}</script><link href=/css/syntax.min.css rel=stylesheet><link href=/css/copy-to-clipboard.min.css rel=stylesheet></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title=伊恩的開發狂想 rel=home><div class="logo__item logo__imagebox"><img class=logo__img alt=logo src=/img/placeholder.png></div><div class="logo__item logo__text"><div class=logo__title>伊恩的開發狂想</div><div class=logo__tagline>在知識大海中漂流的小船，不停追尋屬於自己的秘寶。專注於 .NET、雲端技術、系統架構、開發技巧的道、法、術。</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>程式碼版控 - 觀念與 Git 簡述</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>伊恩</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-07-29T10:14:10+08:00>2022-07-29</time>
<time class=meta__text datetime=2023-01-12T07:14:12Z>(Last Modified: 2023-01-12)</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/ rel=category>軟體開發</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#版本控制系統-version-control-system-vcs>版本控制系統( Version Control System, VCS)</a><ul><li><a href=#集中式版本控制系統centralized-vcs>集中式版本控制系統(Centralized VCS)</a></li><li><a href=#分散式版本控制系統-distributed-vcs>分散式版本控制系統 (Distributed VCS)</a></li><li><a href=#版本控制的幾點建議>版本控制的幾點建議</a></li></ul></li><li><a href=#git-簡說>Git 簡說</a><ul><li><a href=#git-本地端的使用>Git 本地端的使用</a></li><li><a href=#git-分支>Git 分支</a></li><li><a href=#git-與遠端同步>Git 與遠端同步</a></li></ul></li><li><a href=#git-flow>Git Flow</a><ul><li><a href=#branch-規則>Branch 規則</a></li><li><a href=#git-flow-的爭議點>Git Flow 的爭議點</a></li><li><a href=#git-flow-使用經驗與建議>Git Flow 使用經驗與建議</a></li></ul></li><li><a href=#延伸閱讀>延伸閱讀</a></li></ul></nav></div></div><div class="content post__content clearfix"><blockquote><p><a href=https://ithelp.ithome.com.tw/users/20107551/ironman/1906>2019 iT 邦幫忙鐵人賽</a>文章補完計劃，<a href=https://eandev.com/post/series/build-automated-deploy/build-ci-cd-from-scratch/#版控篇>從零開始建立自動化發佈的流水線</a> 版控篇</p></blockquote><p>當軟體持續發展，難免出現客制化需求，或是要求針對特定版本進行功能異動，尤其是團隊協作的情況下，有沒有那種方式可以提供有效的統整現有的程式碼，讓協作開發人員，都可以取得最新的開發版本。也可以快速的調出過往的程式異動版本，以便追查問題或調整。</p><pre tabindex=0><code class=language-chat data-lang=chat>吉米與 Eric 相約在咖啡廳會面後，閒聊一會後，吉米直接將自己遇到的情況詳細說明給 Eric 知道。並詢問是否有其他建議的作法。

Eric:
  吉米，你目前的原始碼，是使用什麼方式來進行管控？

吉米:
  大多都是在交付軟體時，才會將程式碼所在的資料夾壓縮成 zip 檔，用這種方式來管理程式碼的版本。

Eric:
  嗯，聽起來你是使用本地版本管控 的概念，來管理你的程式碼。不過這種備份方式，萬一需要比對程式碼差異時，需要額外花費一番功夫。

吉米:
  確實，之前有幾次要確認某個功能，是從那一個版本之後才新增的，花了不少時間去進行程式碼的比對。

Eric:
  你交付軟體的間隔時間大約多久？

吉米:
  一般來說，大約一個月到兩個月左右，就會交付軟體給客戶。

Eric:
  除了在交付程式時的備份外，其他時間也會進行備份嗎？針對這些程式碼壓縮檔，有異地備份嗎？

吉米:
  都是在完成某一項功能後，如果有想到備份，才會備份，但大部份都會忘記。至於備份下來的壓縮檔，都會同步到網路硬碟。

Eric:
  嗯，大致了解你的情況。吉米，你的程式碼版本管控的方式，風險相當高。例如開發環境突然掛掉、軟體開發到一半，突然發現方向錯誤……，雖然都可以解決，但都需要花費額外的時間去處理。

吉米:
  嗯嗯，換個角度來說，這就是隱性(時間)成本的耗損吧。

Eric:
  沒錯！看起來你現在需要的是版本管控系統來協助你管理原始碼，如果沒有使用其他的版控軟體，建議你可以去用許多開發人員使用的版控軟體 Git。
</code></pre><h2 id=版本控制系統-version-control-system-vcs>版本控制系統( Version Control System, VCS)</h2><p>在版本控制系統中，最重要的，莫過於「<strong>倉庫(Repository)</strong>」，在 Repository 中，會記錄所有的版本資訊、<strong>分支(Branch)</strong>、<strong>合併(Merge)</strong> 等等資料。而版控所有的指令，都是建立於系統對 Repository 的操作行為。</p><p>此外，版本控制系統，也一定存在<strong>同步</strong>、<strong>追溯</strong>與<strong>檔案備份</strong>，這三種特性。</p><ul><li>同步 - 確保每個使用者，最終取回的內容都是相同的。</li><li>追溯 - 可以知道所有版本間的變動項目與原因，也能回復到歷史版本中的任一版本。</li><li>檔案備份 - 因為將所有的變動都同步到 Respository，間接的達到備份的功用。</li></ul><p>目前主流的版本控制系統的架構，大致上，都可以歸屬於<strong>集中式</strong>與<strong>分散式</strong>這兩種類型。在下面的圖中，Subversion 就是集中式版本控制系統，Git 則是分散式版本控制系統。</p><p><img src=centralized-vs-distributed-advantages.png alt="advantages of distributed version control systems">
(圖片出處: <a href=https://scriptcrunch.com/295/>Scriptcrunch</a>)</p><h3 id=集中式版本控制系統centralized-vcs>集中式版本控制系統(Centralized VCS)</h3><p>集中式的版本控制系統，就是基於……同個團隊之間合作的方式，是共用同一個 Repository。系統必須確保每位使用者都需與 Respository 保持一致。為要維持使用者之間保持同步的狀態，分為 <strong>鎖定模式</strong> 與 <strong>合併模式</strong> 兩種作法。</p><ul><li><p><strong>鎖定模式</strong></p><p>當使用者想要修改某檔案、簽出該檔案後，該檔案便會進入鎖定狀態，其他使用成員便無法加以修改，直到簽出者將該檔簽回為止。</p><p>對於維持同步來說，這當然是一個十分保險的作法，因為永遠不會有兩個或以上的使用者同時修改同一個檔案。</p><p>只是，這種方法造成了使用者對於檔案修改的互斥效應，使得使用效率受到影響。</p></li><li><p><strong>合併模式</strong></p><p>允許多位使用者同時針對同一檔案進行修改，當他們分別將檔案提交回集中的檔案庫時，若發生衝突的情況，便會自動進行合併，而若自動合併失敗，再要求人工進行衝突的調解。</p></li></ul><p>對於 Subversion SVN 版本控管有興趣的話，可以延伸閱讀 DEMO 大的 <a href=https://demo.tc/post/702>Subversion SVN 版本控管</a>，針對 SVN 寫了一系列的教學文章。</p><h4 id=集中式版本控制不足處>集中式版本控制不足處</h4><ul><li><p>無法離線工作</p><p>因為所有使用者共用同一個 Respository ，因此 Respository 幾乎存放在網路可連結的主機。使用者想要對 Respository 進行任何動作，都必須在能夠連網的環境下進行。</p></li><li><p>動一鬆而牽全身</p><p>如果某一個使用者，在檔案修改的過程中，就提交到 Respository ，那麼，便有可能影響到 Respository 內的檔案，處於不穩定或異常的狀態。</p><p>若強制使用者必需修成完成後，才能提交檔案至 Respository。但是，在修改的過程中，使用者無法得到版本控制系統的支援，有效控制各階段的修改內容。</p></li></ul><h3 id=分散式版本控制系統-distributed-vcs>分散式版本控制系統 (Distributed VCS)</h3><p>分散式的版本控制系統允許 Respository 存在一份或多份。每個使用者，都可以在自己電腦中，建立 Respository。</p><p>對於分散式版本控制系統而言，讓每個使用者都可以修改各自的 Respository，享受版本控制系統的支援，而不受其他因素的限制。</p><p>同時，運用 Push、Pull 的動作，使用者之間可分享自己的變更內容，達到同步的結果。因此，為了更有效的同步版本內容，分散式版本控制系統就更重視 Branch、Merge 的支援與功能。</p><p><img src=basic-remote-workflow.png alt="sauvegarder : git flow"></p><p>(圖片出處: <a href=https://www.git-tower.com/learn/git/ebook/en/command-line/remote-repositories/introduction>www.git-tower.com</a>)</p><p>在分散式版本控制系統中，分成本地端與遠端 Repository。</p><p>在本地端，為了確實的管控所有的檔案變更與異常，並讓使用者充分的運用到版本控制系統的支援。分成<strong>工作區(Working Copy/Working Directory)</strong>、<strong>暫存區(Staging area)<strong>以及</strong>本地Repository</strong>。</p><ul><li><p>工作區</p><p>這個部份，是我們進行檔案操作的位置。不管是 <strong>切換 (checkout)</strong>、<strong>複制 (clone)</strong>、<strong>重置 (reset)</strong>、<strong>拉 (pull)</strong>，<strong>複原 (discard)</strong> 等動作結果，都會直接影響這邊。</p></li><li><p>暫存區</p><p>當工作複本內容檔案修改後，會將要上傳變更的內容快照一份放在這邊。在 <strong>提交 (commit)</strong> 時，會將這區域內的資料，上傳到到 Repository。</p></li><li><p>本地 Repository</p><p>保存了所有變更過的檔案，以及各版本的歷史紀錄。</p></li></ul><p>在遠端，也會存在一個<strong>遠端 Repository</strong>，以儲存管理所有使用者，所上傳的最終變更的版本資訊。同時，也是它提供其他使用者同步資訊的共同來源。利用 <strong>推(push)</strong>、<strong>拉 (pull)</strong>、<strong>複制 (clone)</strong>、<strong>拿取(fetch)</strong> 等動作，來達到同步旳結果。</p><h3 id=版本控制的幾點建議>版本控制的幾點建議</h3><ul><li><p>適時的 <strong>提交(Commit)</strong> 變動</p><ol><li><p>每次的 Commit ，盡可能的確實變動內容的單純性與獨主性。例如，這次 Commit 的 Fix Bug 的變動，那在變動的內容，應盡可能避免與 Fix Bug 無關的內容。</p></li><li><p>每次的 Commit，都應確保變更後內容，是可以順利 Build 的。</p></li></ol></li><li><p>良好的 Commit 訊息</p><p>每次的 Commit ，確認描述此次變動的原因與修改內容。利用有效的訊息，提高軟體的維護性。</p></li></ul><h2 id=git-簡說>Git 簡說</h2><pre tabindex=0><code class=language-chat data-lang=chat>Eric:
  簡單說明「集中式版本控制」與「分散式版本控制」兩者之間的差異，其中 Subservion 是很經典的集中式版制系統。
  不過，因為你之前沒有使用過版控系統，個人建議使用分散式散本控制系統中的 Git。

吉米:
  為什麼 Eric 你會建議使用 Git 呢？

Eric:
  目前 Git 被許多開發人員使用。再者，有許多的網路服務商提供免費或付費的服務，這部份想必對你有也會很多的幫助。

吉米:
  這麼說來，使用這些網路服務的同時，就等於又多一個備份的機制。

Eric:
  沒錯。

吉米:
  聽完你的說明後，對分散式版本控制系統的架構與流程，有比較客觀的認識。當我在本地端，將版控系統建立起來後，就可以立即享受版控帶來的支援與好處。
  等到那天，需要在其他台電腦或與其他人協合開發時，也可以利用遠端 Repository 來同步開發的進度。

Eric:
   沒錯，接著，我們來了解 Git 本地端的使用方式。
</code></pre><h3 id=git-本地端的使用>Git 本地端的使用</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># Init</span>
</span></span><span style=display:flex><span>git init
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 提交 commit</span>
</span></span><span style=display:flex><span>git commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 切換 checkout</span>
</span></span><span style=display:flex><span>git checkout master
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 重置 reset</span>
</span></span><span style=display:flex><span>git reset C3
</span></span></code></pre></div><pre tabindex=0><code class=language-chat data-lang=chat>Eric:
  剛剛提到的 commit、checkout、reset 都是在基本的版本管理與記錄，只會這些是無法支援多變的開發需求的。

吉米:
  確實，假若遇到部份功能客制化的需求，這些指令好像無法派上用途，難道要再建一個新的 Repository 嗎？

Eric:
  哈哈，當然不是。所以接下來，要提到  branch、merge 的觀念了。
</code></pre><h3 id=git-分支>Git 分支</h3><p>當我們使用 Git 時，一定會有一條主線 master，但是在實務上，有時會遇到幾種狀況。(PS: 由於 2020 年的黑人平權運動，已逐漸調整名稱為 main)</p><ul><li>功能己經寫了一半，但客戶突然告知要放棄該功能。</li><li>針對現有的軟體，業務跟你說，某客戶要求增修某個功能，但這功能只是個案。</li><li>……</li></ul><p>像這個時候，為了跟原本軟體版本有所差異，只好分成不同支線來控制版本，以方便管理。但最後，別忘了評估那些功能可以合併回主線，盡可能避免無限開分支的情況。</p><p>別忘了，當要維護的分支越多，對開發人員的負擔就越大。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># 分支 branch</span>
</span></span><span style=display:flex><span>git branch develop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 合併 merge</span>
</span></span><span style=display:flex><span>git merge master
</span></span></code></pre></div><h3 id=git-與遠端同步>Git 與遠端同步</h3><pre tabindex=0><code class=language-chat data-lang=chat>Eric:
  說完 branch、merge 的觀念後，接著來聊聊 遠端 Repository 與 本地端 Repository 的同步。

吉米:
  嗯嗯，記得先前你有提到 push、pull、clone、fetch  這幾個名詞。

Eric:
  說到本地端與遠端的同步，不外乎就是 把資料丟上去的 push，以及把資料抓下來的 clone、fetch、pull。接下來，我們來聊一下 clone、fetch、clone 三者的差異。
</code></pre><p>因為本地端在沒有設定前，它並不知道遠端 Repository 的位置。所以要同步資訊到遠端前，必需先將遠端 Repository 建立起來後，將它跟本地端進行綁定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># 設定 Remote Repository</span>
</span></span><span style=display:flex><span>git remote add origin http<span style=color:#960050;background-color:#1e0010>:</span>//xxxx.xxx.xx.xx/ironman/git_tech.git
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># push 方法一</span>
</span></span><span style=display:flex><span>git push origin master
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># push 方法二: 指定遠端的分支名稱</span>
</span></span><span style=display:flex><span>git push origin master<span style=color:#960050;background-color:#1e0010>:</span>master
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># fetch: 確認本地與遠端的異常，此時並不會真正的下載遠端的資料</span>
</span></span><span style=display:flex><span>git fetch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># pull: 確認本地與遠端的異常，並下載遠端資料</span>
</span></span><span style=display:flex><span>git pull
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># clone: 將遠端資料複制於本地端。</span>
</span></span><span style=display:flex><span>git clone
</span></span></code></pre></div><pre tabindex=0><code class=language-chat data-lang=chat>Eric:
  說了這麼多，但還有很有很多指令都還沒有提到，像 request push、rebase 等等，有機會你再去好好了解它們的用法。

吉米:
  這樣就對有我很大的幫助。不過，對於我這樣的新手，git 沒有提供 GUI 工具呢？

Eric:
  好問題，在 Git 官網中，有提供 GUI Client 的軟體清單，提供下載，可以選擇自己喜歡的軟體。
</code></pre><h2 id=git-flow>Git Flow</h2><pre tabindex=0><code class=language-chat data-lang=chat>吉米在了解 Git 版本控制的觀念後，使用了兩週的時間，發現自己無法很好的管理分支與控制變動。
在網路上找到 git flow 的介紹，但研究後，還是有部份的疑問。
因此，吉米打電話跟 Eric 請教 git flow 的問題。

Eric:
  喂，我是 Eric，那裡找？

吉米:
  我是吉米，Eric 現在方便講電話嗎？有些事想請教你一下。

Eric:
 可以啊，什麼事？

吉米:
 我使用 Git 進行版控到現在，發現不知道要怎麼管理分支。後來我在網路上，看到有人推薦 git flow，又看到有人說 git flow 不建議使用。想詢問一下你的看法。

Eric:
 原來如此，那我們分析一下 git flow 的特點吧。
</code></pre><p>gitflow 是 Vincent Driessen 在 2010 年提出來的一種關於 git 工作流程的建議。</p><p><img src=https://nvie.com/img/git-model@2x.png alt=git-model@2x></p><p>(圖片來源: <a href=https://nvie.com/posts/a-successful-git-branching-model/>A successful Git branching model</a>)</p><h3 id=branch-規則>Branch 規則</h3><p>在 git flow 中，有兩支最重要的 branch，分別是 <strong>master</strong>、<strong>develop</strong> 。</p><h4 id=master>Master</h4><p>原本的主線，但在 git flow 中，比較接近交付給客戶的產品版本。因此，會變更到 master 的時機點，只有在完成 <strong>release</strong> 與 <strong>hotfix</strong> 後，才會變動。</p><h4 id=develop>Develop</h4><p>develop 是基於 master 所分支出的 <strong>開發用主線</strong>。當採用 git flow 作為管理方式時，會自行從 master 開一支名為 develop 的分支。</p><p>所有對於需求的新增、修改，或是問題的修正，都會在此作業。直到完成開發後，才會用 <strong>release</strong> ，與 master 進行同步。</p><h4 id=feature>Feature</h4><p>所有功能的增加、修改，會不同的需求目標，開一條前綴為 <strong>feature</strong> 的分支。直到完成功能的開發後，就會 merage 回 develop。</p><p>而每個 feature 只處理各自需求目標。也就是<strong>一次( feature)只做一件事 (功能)</strong>。</p><h4 id=release>Release</h4><p>當預定的功能都開發完成時，這時就會開一條前綴為 <strong>release</strong> 的分支，此時，只能針對預備釋出的功能，進行 <strong>現有功能的錯誤修正</strong>。</p><p>確定所有功能正常無誤，完成 release 後，會先後 merge 到 master 與 develop。</p><h4 id=hotfix>HotFix</h4><p>當交付的軟體回報有問題時，會開前綴為 <strong>hotfix</strong> 的分支。完成修正後，會先後 merge 到 master 與 develop。</p><h3 id=git-flow-的爭議點>Git Flow 的爭議點</h3><p>目前 git flow 主要的爭議點，就筆者看到的，大約可分成兩點。</p><ul><li>develop/master 的分割</li><li>多人協作時，完成 feature 時的衝突。</li></ul><h4 id=developmaster-的分割>develop/master 的分割</h4><p>這可能是因為 develop 與 master 的功用相近，但在 git flow 的流程下，操作相當變得複雜。尤其在講求 <strong>快速交付</strong> 的現在，執行 DevOps 的人眼中看來，develop 存在的意義不大。</p><p>但在某些軟體公司而言，因為客戶性質的關係，交付軟體的週期較長。master/develop 可以確保產品維護的同時，又可以進行開功能的開發。</p><p>或是開發過程的異動太大，develop 的異動，不會直接影響到 master，就也就己交付軟體的內容。</p><h4 id=多人協作時完成-feature-時的衝突>多人協作時，完成 feature 時的衝突</h4><p>會發生這個問題，多數是由於負責功能項目，在程式內的耦合性太高，導致兩個 feature 以上，去變更到同一份文件。</p><p>這部份能從幾個部份下手，例如 <strong>開發人員之間的溝通協商</strong>、<strong>增加 push 時的審核機制</strong>，例如 Github 所使用的 pull request 機制。或是<strong>優化軟體架構</strong>，讓它其中的物件低耦合，高內聚。</p><h3 id=git-flow-使用經驗與建議>Git Flow 使用經驗與建議</h3><ol><li>針對 Feature，要實作的功能範圍應該可能的小，以確保該功能可以在半個到一個工作日內完成。</li><li>每天工作前，都應該 Fetch 最新版本。下班前，將完成的 feature push 。</li><li>軟體架構內物件，要盡可能的低耦合高內聚，才能減少功能修改時的交互影響。</li></ol><pre tabindex=0><code class=language-chat data-lang=chat>吉米:
  Eric，聽完你的說明，感覺 git flow 就可以立即套用。

Eric:
  剛好目前你一個人獨立開發，而在這個時機點，git flow 正好適合你用。如果以後多人協同開發的時候，可能就要搭配其他流程，如 Github flow、Gitlab flow 等等，以便管理，

吉米:
  嗯嗯，適合的最好，以後如果有用到其他的流程，再跟你請救。

Eric:
  哈哈，歡迎歡迎，跟你解釋的同時，我也順便再次理清思慮。沒其他事的話，打電話我就先掛了。

吉米:
  OK，拜拜。

Eric:
  拜拜。
</code></pre><h2 id=延伸閱讀>延伸閱讀</h2><p>▶ 版控觀念</p><ol><li><a href=http://toolsqa.com/git/local-central-and-distributed-version-control-systems/>Local, Central and Distributed Version Control Systems</a></li><li><a href=https://ihower.tw/blog/archives/8076>三個使用版本控制系統的建議</a></li><li><a href=https://blog.github.com/2015-01-21-how-to-write-the-perfect-pull-request/>How to write the perfect pull request</a></li><li><a href=https://www.ithome.com.tw/article/97328>卓越開發者必備的版本控制技巧</a></li></ol><p>▶ Git</p><ol><li><a href=https://git-scm.com/downloads/guis>Git 官網</a></li><li><a href=https://backlog.com/git-tutorial/tw/>連猴子都能懂的 Git 入門指南</a></li><li><a href=https://ithelp.ithome.com.tw/users/20004901/ironman/525>30 天精通 Git 版本控管</a></li><li><a href=https://learngitbranching.js.org/>Learn Git Branching</a></li><li><a href=https://demo.tc/post/702>Subversion SVN 版本控管</a></li><li><a href=https://legacy.gitbook.com/book/kingofamani/git-teach/details>Git 教學</a></li><li><a href=https://www.ithome.com.tw/news/95283>Git 達人教你搞懂 GitHub 基礎觀念</a></li><li><a href=https://gitbook.tw/>為你自己學 Git</a></li></ol><p>▶ Git Flow</p><ol><li><a href=https://gitbook.tw/chapters/gitflow/why-need-git-flow.html>Git Flow 是什麼？為什麼需要這種東西？</a></li><li><a href=https://nvie.com/posts/a-successful-git-branching-model/>A successful Git branching model</a></li><li><a href="http://www.brofive.org/?p=2233">GitLab Flow：介于GitFlow和Github Flow之间！</a></li><li><a href=https://www.endoflineblog.com/follow-up-to-gitflow-considered-harmful>Follow-up to ‘GitFlow considered harmful’</a></li><li><a href=https://blog.hellojcc.tw/2017/12/14/the-flaw-of-git-flow/>git flow 實戰經驗談 part1 - 別再讓 gitflow 拖累團隊的開發速度</a></li><li><a href=https://blog.hellojcc.tw/2018/01/11/a-better-git-flow/>git flow 實戰經驗談 part2 - 可能更好的 gitflow</a></li><li><a href=https://blog.wu-boy.com/2017/12/github-flow-vs-git-flow/comment-page-1/>GitHub Flow 及 Git Flow 流程使用時機</a></li><li><a href=https://ihower.tw/blog/archives/5140>Git flow 開發流程</a></li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><a class=tag href=/tags/%E7%89%88%E6%8E%A7/ rel=tag>版控</a></ul></div></footer><div><p>文章內容均為個人學習記錄、心得與認知，若任何謬誤或建議，歡迎直接留言討論，一同成長。</p></div><iframe class=LikeCoin src="https://button.like.co/in/embed/wosilee/button?referrer=https%3a%2f%2feandev.com%2fpost%2fseries%2fbuild-automated-deploy%2fversion_control%2f" height=200 width=100% frameborder=0></iframe>
<script src=/js/copy-code-clipboard.min.js></script></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/architecture/%E8%81%8A%E8%81%8A%E6%9E%B6%E6%A7%8B-%E7%B3%BB%E7%B5%B1%E8%B2%A0%E8%BC%89%E5%88%86%E6%B5%81%E8%88%87%E9%99%90%E5%88%B6%E7%90%86%E8%AB%96/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>聊聊架構 - 系統負載、分流與限制理論</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/series/build-automated-deploy/yaml/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>淺談 YAML 格式</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//eanblog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 伊恩軟體技術學習與分享.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>