<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Docker 操作簡介 - command / dockerfile / docker-compose - 伊恩的開發狂想</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7903108559996033" crossorigin=anonymous></script><meta name=description content="在順利完成 Docker 的安裝後，接下來就是進一步了解如何操作 Docker 的指令了。但是這樣還不夠，我們還想要一鍵同時啟用多個 container，以及自行建立 Docker Image。"><meta property="og:title" content="Docker 操作簡介 - command / dockerfile / docker-compose"><meta property="og:description" content="在順利完成 Docker 的安裝後，接下來就是進一步了解如何操作 Docker 的指令了。但是這樣還不夠，我們還想要一鍵同時啟用多個 container，以及自行建立 Docker Image。"><meta property="og:type" content="article"><meta property="og:url" content="https://eandev.com/post/series/build-automated-deploy/docker-operate/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-01-09T01:47:58+00:00"><meta property="article:modified_time" content="2023-01-09T01:47:58+00:00"><meta itemprop=name content="Docker 操作簡介 - command / dockerfile / docker-compose"><meta itemprop=description content="在順利完成 Docker 的安裝後，接下來就是進一步了解如何操作 Docker 的指令了。但是這樣還不夠，我們還想要一鍵同時啟用多個 container，以及自行建立 Docker Image。"><meta itemprop=datePublished content="2023-01-09T01:47:58+00:00"><meta itemprop=dateModified content="2023-01-09T01:47:58+00:00"><meta itemprop=wordCount content="991"><meta itemprop=keywords content="Docker,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 操作簡介 - command / dockerfile / docker-compose"><meta name=twitter:description content="在順利完成 Docker 的安裝後，接下來就是進一步了解如何操作 Docker 的指令了。但是這樣還不夠，我們還想要一鍵同時啟用多個 container，以及自行建立 Docker Image。"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.min.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-4HXSCXTZKZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4HXSCXTZKZ",{anonymize_ip:!1})}</script><link href=/css/syntax.min.css rel=stylesheet><link href=/css/copy-to-clipboard.min.css rel=stylesheet></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title=伊恩的開發狂想 rel=home><div class="logo__item logo__imagebox"><img class=logo__img alt=logo src=/img/placeholder.png></div><div class="logo__item logo__text"><div class=logo__title>伊恩的開發狂想</div><div class=logo__tagline>在知識大海中漂流的小船，不停追尋屬於自己的秘寶。專注於 .NET、雲端技術、系統架構、開發技巧的道、法、術。</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Docker 操作簡介 - command / dockerfile / docker-compose</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>伊恩</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-01-09T01:47:58Z>2023-01-09</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/container/ rel=category>Container</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#docker-command>Docker command</a><ul><li><a href=#image>Image</a></li><li><a href=#container>Container</a></li></ul></li><li><a href=#建立-docker-image>建立 Docker Image</a><ul><li><a href=#dokcerfile-格式>Dokcerfile 格式</a></li><li><a href=#dockerignore>.dockerignore</a></li><li><a href=#建立-image-檔>建立 Image 檔</a></li></ul></li><li><a href=#docker-compose>Docker Compose</a><ul><li><a href=#docker-composeyml-範例>docker-compose.yml 範例</a></li></ul></li><li><a href=#延伸閱讀>延伸閱讀</a></li></ul></nav></div></div><div class="content post__content clearfix"><blockquote><p><a href=https://ithelp.ithome.com.tw/users/20107551/ironman/1906>2019 iT 邦幫忙鐵人賽</a>文章補完計劃，<a href=https://eandev.com/post/series/build-automated-deploy/build-ci-cd-from-scratch/#ontainer>從零開始建立自動化發佈的流水線</a> Container 篇</p></blockquote><p>在上一篇 <a href=https://eandev.com/post/series/build-automated-deploy/container-intro/>部署新境界 - 使用 Container 簡化流程</a> 中，初步了解 Virtual Machine 與 Container 的差異、Docker 的歷史背景與安裝方式。</p><p>接下來，讓我們來進一步了解 Docker 相關的指令與操作方式。</p><h2 id=docker-command>Docker command</h2><pre tabindex=0><code class=language-Plan data-lang=Plan>Eric:
  Docker 成功安裝後，我們試著對 docker 的進行一些基本操作。
</code></pre><p>若需確認機器上運行的 Docker 版本，可以使用以下指令來進行查詢。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span>docker --version<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 取回的資料較為詳細</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>docker version<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><img src=Images/docker_version.png alt="Docker version"></p><h3 id=image>Image</h3><p>在建立運行服務的 Container 時，一定要指定使用的 Image。Docker 才有辦法建立基於 Image 的 Container。所以說 Image 是 Docker 的核心，也不為過。</p><p>可以使用 <code>docker image --help</code> 查詢所有與 Image 相關的操作。</p><p><img src=Images/docker_image_help.png alt="docker image &amp;ndash;help"></p><p>雖然操作 Image 的指令很多，但最常用的指令有四種。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 取得本地當下存放的 Image</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 可以檢視到 Image 的名稱、建立時間與大小</span>
</span></span><span style=display:flex><span>docker image ls
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 從 remote repository 下載 image，若沒有指定 Tag，預設會下載 latest</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 預設位置為 Docker Hub，可找到許多現成的 Image。</span>
</span></span><span style=display:flex><span>docker pull NAME:<span style=color:#f92672>[</span>Tag<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 執行 Image，建立 Container</span>
</span></span><span style=display:flex><span>docker run NAME:<span style=color:#f92672>[</span>Tag<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 移除 image</span>
</span></span><span style=display:flex><span>docker image rm IMAGE
</span></span><span style=display:flex><span>docker rmi IMAGE
</span></span></code></pre></div><p>接著來實際操作指令，進行 Image 的 查詢、下載、移除等動作。</p><p><img src=Images/docker_cmd_image_ls.png alt="docker image ls"></p><p><img src=Images/docker_cmd_pull_image.png alt="docker pull"></p><p><img src=Images/docker_cmd_image_ls_2.png alt="docker image ls"></p><p><img src=Images/docker_cmd_rm_image_success.png alt="docker remvoe image"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># create/build image</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>docker image build <span style=color:#f92672>[</span>dockerfile path<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>當發現沒有適合的 Image 時，也可以自行建立 Image。建立 Image 時，Docker 會依據 YAML 格式所撰寫的 Dockerfile 內參數設定，來建立 Image。在 <a href=#%E5%BB%BA%E7%AB%8B-docker-image>dockerfile</a> 會進一步介紹。</p><h3 id=container>Container</h3><p>常用的 Container 指令如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 查看目前的 container 清單</span>
</span></span><span style=display:flex><span>docker ps
</span></span><span style=display:flex><span>docker container ls
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 啟動已停止的 Container</span>
</span></span><span style=display:flex><span>docker start <span style=color:#f92672>[</span>CONTAINER ID<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>docker container start <span style=color:#f92672>[</span>CONTAINER ID<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 停止執行中的 Container</span>
</span></span><span style=display:flex><span>docker start <span style=color:#f92672>[</span>CONTAINER ID<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>docker container start <span style=color:#f92672>[</span>CONTAINER ID<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>先前，已經從 Docker Hub 取得 busybox 的 image，接著，我們使用 <code>docker run busybox</code> 的方式，告知 Docker Engine ，以 busybox Image 啟動 container。</p><p><img src=Images/docker_cmd_run.png alt="docker run"></p><p>在啟動 container 後，可以使用下述的指令，進行確認 container 目前的狀態。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 查看目前的 container 清單</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 作法一</span>
</span></span><span style=display:flex><span>docker container ls
</span></span><span style=display:flex><span><span style=color:#75715e># 作法二</span>
</span></span><span style=display:flex><span>docker ps
</span></span></code></pre></div><p>但是，執行上述的指令取得的結果，會發現查不到任何資料，找不到與 busybox 相關的 container。</p><p>這是因為 busybox 在完成動作後，就會直接結束。而 <code>docker ps</code> 只會列出執行中的 container。所以必需在加上 <code>-a</code> 的參數，要求列出所有的 Container。</p><p><img src=Images/docker_cmd_container_ls.png alt="docker container ls"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 啟動已停止的 Container</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 作法一</span>
</span></span><span style=display:flex><span>docker start <span style=color:#f92672>[</span>CONTAINER ID<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 作法二</span>
</span></span><span style=display:flex><span>docker container start <span style=color:#f92672>[</span>CONTAINER ID<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>假若要執行的 container 己經存在，可以運用 <code>start</code> 來啟動己經停止的 container。在下圖可以發現的狀態有所變動。</p><p><img src=Images/docker_container_start.png alt="docker container start"></p><p>若看到己經執行完成的 container 一直存在清單之中，覺得怪不舒服。可以用 <code>docker conatiner prune</code> 將一口氣已停止的 container 刪除。</p><p>下這個指令，請<strong>務必、務必、務必確認已停止的 Container 沒有需要保留，不然清除後可是救不回來的。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># remove stopped container</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>docker conatiner prune<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><img src=Images/docker_container_prune.png alt="container prune"></p><p>相同的，如果要一口氣移除無用的 container、Volume、Network，則可以使用 <code>docker system prune</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#75715e># remove unused data</span>
</span></span><span style=display:flex><span>docker system prune
</span></span></code></pre></div><h2 id=建立-docker-image>建立 Docker Image</h2><pre tabindex=0><code class=language-Plan data-lang=Plan>Eric:
  現在對 docker 的基本操作，有一定的了解了。但這樣還不能滿足我們的需求。

吉米:
  那接下來的重點，就是把公司現在的服務轉成 Docker Image，這樣才能利用 Docker 所提供的服務。

Eric:
  沒錯，接著來聊聊建立 docker image 的方法，以及 dockerfile 的設定。
</code></pre><h3 id=dokcerfile-格式>Dokcerfile 格式</h3><p>Docker 在建立 image 時，會依據 <code>dockerfile</code> 的內容來進行建製的。而 <code>dockerfile</code> 就是 YAML 格式撰寫的指令檔。其中記錄使用者在編譯 docker image 時，所有的 <strong>命令列 (Command-Line)</strong>。</p><p>筆者個人認為，dockerfile 最重要的 <code>FORM</code>、<code>COPY</code>、<code>RUN</code>、<code>CMD</code> 正好對應 docker image 從建立到執行的四階段。</p><h4 id=初始設定>初始設定</h4><ul><li><p><code>FROM</code> 指定 docker image 建立時，使用的底層 (Base Image)。**</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> &lt;image&gt; [AS &lt;name&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><p><del><code>MAINTAINER</code> 維護者的相關資訊。</del> (官方己經棄用，建議使用 <code>LABLE</code>)</p></li><li><p><code>LABLE</code></p><p>The <code>LABEL</code> instruction adds metadata to an image. A <code>LABEL</code> is a key-value pair.</p><p>To include spaces within a <code>LABEL</code> value, use quotes and backslashes as you would in command-line parsing.</p></li><li><p><code>ENV</code></p><p><code>ENV</code> 使用 key-value 的結構，來設定 Container 所使用的環境變數。</p><p>This value will be in the environment for all subsequent instructions in the build stage and can be <a href=https://docs.docker.com/engine/reference/builder/#environment-replacement>replaced inline</a> in many as well.</p></li></ul><h4 id=配置>配置</h4><ul><li><p>程式的配置</p><ul><li><p><code>COPY</code> 複制檔案或資料夾到 container 的檔案系統內。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> &lt;image&gt; [AS &lt;name&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><p><code>ADD</code> 除了 <code>copy</code> 的功能外，額外支援 URL 的資料來源。</p></li></ul></li><li><p>環境的配置</p><ul><li><p><code>EXPECT</code></p><p>指定 container 在執行時，所開放使用 TCP 或 UDP 的 PORT。若沒有特別指定 TCP/UDP 的話，預設使用 TCP。</p><p>但是，<code>EXPECT</code> 實際上並非真的公開端口。它更像是 執行 container 時，與 Image 內部的溝通窗口。</p><p>所以，在執行 container 時，要使用公開端口，記得要加上 <code>-p</code> 的參數。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># 網路 port=80 對應到 container port=80</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>docker run -p 80:80/tcp<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><p><code>VOLUMN</code></p><p>The <code>VOLUME</code> instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers.</p></li></ul></li></ul><h4 id=建立-image-layer>建立 Image Layer</h4><ul><li><p><code>RUN</code> builds your application with <code>make</code>.</p><p>RUN 指令，將會基於目前的映像檔上，執行命令，並產生新的映像檔，以提供 Dockerfile 中的下一步使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># 1. shell 型式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> &lt;command&gt; <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># exec 型式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;executable&#34;</span>, <span style=color:#e6db74>&#34;param1&#34;</span>, <span style=color:#e6db74>&#34;param2&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><h4 id=啟動-container>啟動 container</h4><ul><li><p><code>CMD</code> specifies what command to run within the container.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># CMD 有三種操作的方式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># exec 型式 (建議優先選取此方式)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;executable&#34;</span>,<span style=color:#e6db74>&#34;param1&#34;</span>,<span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 將預設參數傳給 ENTRYPOINT</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;param1&#34;</span>,<span style=color:#e6db74>&#34;param2&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># shell 形式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> command param1 param2<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li><li><p><code>ENTRYPOINT</code></p><p>An <code>ENTRYPOINT</code> allows you to configure a container that will run as an executable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#75715e># ENTRYPOINT 有兩種方式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># exec 型式 (建議優先選取此方式)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;executable&#34;</span>, <span style=color:#e6db74>&#34;param1&#34;</span>, <span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#f92672>(</span>exec form, preferred<span style=color:#f92672>)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># shell 形式</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> command param1 param2 <span style=color:#f92672>(</span>shell form<span style=color:#f92672>)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul><p>When you run an image and generate a container, you add a new <em>writable layer</em> (the “container layer”) on top of the underlying layers. All changes made to the running container, such as writing new files, modifying existing files, and deleting files, are written to this thin writable container layer.</p><h3 id=dockerignore>.dockerignore</h3><p>Before the docker CLI sends the context to the docker daemon, it looks for a file named <code>.dockerignore</code> in the root directory of the context. If this file exists, the CLI modifies the context to exclude files and directories that match patterns in it. This helps to avoid unnecessarily sending large or sensitive files and directories to the daemon and potentially adding them to images using <code>ADD</code> or <code>COPY</code>.</p><p>The CLI interprets the <code>.dockerignore</code> file as a newline-separated list of patterns similar to the file globs of Unix shells. For the purposes of matching, the root of the context is considered to be both the working and the root directory. For example, the patterns <code>/foo/bar</code> and <code>foo/bar</code> both exclude a file or directory named <code>bar</code> in the <code>foo</code> subdirectory of <code>PATH</code> or in the root of the git repository located at <code>URL</code>. Neither excludes anything else.</p><p>If a line in <code>.dockerignore</code> file starts with <code>#</code> in column 1, then this line is considered as a comment and is ignored before interpreted by the CLI.</p><h3 id=建立-image-檔>建立 Image 檔</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># build image</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>docker build <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> PATH | URL<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h2 id=docker-compose>Docker Compose</h2><pre tabindex=0><code class=language-plan data-lang=plan>Eric:
  dockerfile 會隨著使用環境的複雜程度，而有所變動。好好的使用，就的達到想要的效果

吉米:
  嗯嗯，使用 docker 來啟動 container 的部份，大致上沒問題了。
  但是如果需要一次啟動多個 container 的話，也有類似批次檔的做法嗎？

Eric:
  有噢，這就是接下來要聊的部份。
  針對需要同時啟動多個 Container 的情境，可以使用 docker compose 可以解決這個需求。
  利用 docker-compose.yml 內的設定，在啟用多個 Container 的同時，也一併完成 Container 之間的關連設定。
  以達到快速佈置的目的。

吉米:
  那還等什麼，我們開始吧。
</code></pre><p><code>docker-compose</code> 是一個用來定義與執行多個 container 的輔助工具。</p><p>當使用 <code>docker-compose up</code> 這個指令，它會去依循 compose file 內的定義，依序啟動多個 container，以及建立它們之間的關連。compose file 預設名稱為 <code>docker-compose.yml</code> 。</p><p>使用 docker-compose ，基本上分為三個步驟</p><ul><li>使用 <code>dockerfile</code> 定義應用程式的環境。</li><li>使用 <code>docker-compose.yml</code> 內的定義，構成應用程式的服務 (service)。</li><li>執行 <code>docker-compose up</code>，啟動並運行整個應用程式。</li></ul><p>在 docker-compose 中，以 <strong>服務(service)</strong> 稱呼使用 compose file 產生出來的物件。</p><p>所以執行 <code>docker-compose --help</code> 時，會看到許多指令的說明，都是以 service 稱呼。</p><p><img src=help.png alt=1542047152230></p><h3 id=docker-composeyml-範例>docker-compose.yml 範例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># docker-compose.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#e6db74>&#34;5000:5000&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>.:/code</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>logvolume01:/var/log</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>links</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>logvolume01</span>: {}
</span></span></code></pre></div><p>從這個範例中，可以看到 <strong>docker-compose.yml 的內容，是以 <a href=https://eandev.com/post/series/build-automated-deploy/yaml/>YAML</a> 格式撰寫。</strong> 包含 compose file 格式的版本、服務內的 container 設定，以及執行環境的設制。</p><p>關於 compose file 內的指令語法，還有許多未能說明的。真的有需求或興趣，可以直接到 Docker 的文件庫內查看。</p><pre tabindex=0><code class=language-Plan data-lang=Plan>吉米:
  既然 docker compose 讓佈置變的這麼方便，那接來下，將它與 CI Server 結合在一起吧。

Eric:
  這正是我們接下來的要進行的內容。

吉米:
  好。
</code></pre><h2 id=延伸閱讀>延伸閱讀</h2><p>▶ Docker Command</p><ol><li><a href=https://legacy.gitbook.com/book/joshhu/dockercommands/details>全面易懂的Docker指令大全</a></li><li><a href=https://legacy.gitbook.com/book/yeasy/docker_practice>Docker —— 从入门到实践</a></li><li><a href=https://philipzheng.gitbook.io/docker_practice/>《Docker —— 從入門到實踐­》正體中文版 (gitbook.io)</a></li></ol><p>▶ Dockerfile</p><ol><li><a href="https://www.netadmin.com.tw/article_content.aspx?sn=1710020002&jump=3">正確撰寫Dockerfile　製作最好用容器映像檔</a></li><li>Docker Document, <a href=https://docs.docker.com/engine/reference/builder/>Dockerfile reference</a></li><li>Docker Document, <a href=https://docs.docker.com/develop/develop-images/dockerfile_best-practices/>Best practices for writing Dockerfiles</a></li><li>peihsinsu, <a href=https://legacy.gitbook.com/read/book/peihsinsu/docker-note-book>Docker學習筆記</a></li></ol><p>▶ Docker Compose</p><ol><li>akira.ohio, <a href=https://www.penflip.com/akira.ohio/appcatalyst-hands-on-lab-en/blob/master/docker-compose.txt>5. Using Docker Compose</a></li><li>Docker Document, <a href=https://docs.docker.com/compose/overview/>Overview of Docker Compose</a></li><li>Docker Document, <a href=https://docs.docker.com/compose/compose-file/>Compose file version 3 reference</a></li><li>TechBridge 技術共筆部落格, <a href=https://blog.techbridge.cc/2018/09/07/docker-compose-tutorial-intro/>Docker Compose 建置 Web service 起步走入門教學</a></li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><a class=tag href=/tags/docker/ rel=tag>Docker</a></ul></div></footer><div><p>文章內容均為個人學習記錄、心得與認知，若任何謬誤或建議，歡迎直接留言討論，一同成長。</p></div><iframe class=LikeCoin src="https://button.like.co/in/embed/wosilee/button?referrer=https%3a%2f%2feandev.com%2fpost%2fseries%2fbuild-automated-deploy%2fdocker-operate%2f" height=200 width=100% frameborder=0></iframe>
<script src=/js/copy-code-clipboard.min.js></script></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/test/talking-testing-report/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>淺談負載測試/壓力測試/效能測試報告</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/series/build-automated-deploy/container-build-execution-environment-required-ci/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>使用 Container 建立 CI 所需要的建置環境</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//eanblog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 伊恩軟體技術學習與分享.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>