<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Docker | 縮網址服務實作記錄 (1) - 基於 Docker 容器技術的網站服務架構實踐 - 伊恩的開發狂想</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7903108559996033" crossorigin=anonymous></script><meta name=description content="本文紀錄使用 Docker Compose 在 Digital Ocean Ubuntu VPS 上架設縮網址服務的過程,包括環境設定、服務架構規劃、Docker image 管理、網路與安全設定等。適合想學習如何利用容器技術架設 Web 服務的讀者。"><meta property="og:title" content="Docker | 縮網址服務實作記錄 (1) - 基於 Docker 容器技術的網站服務架構實踐"><meta property="og:description" content="本文紀錄使用 Docker Compose 在 Digital Ocean Ubuntu VPS 上架設縮網址服務的過程,包括環境設定、服務架構規劃、Docker image 管理、網路與安全設定等。適合想學習如何利用容器技術架設 Web 服務的讀者。"><meta property="og:type" content="article"><meta property="og:url" content="https://eandev.com/post/series/side-project/shorten-1-build-service-base-on-container/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-11-11T14:28:57+08:00"><meta property="article:modified_time" content="2023-11-11T15:22:30+08:00"><meta itemprop=name content="Docker | 縮網址服務實作記錄 (1) - 基於 Docker 容器技術的網站服務架構實踐"><meta itemprop=description content="本文紀錄使用 Docker Compose 在 Digital Ocean Ubuntu VPS 上架設縮網址服務的過程,包括環境設定、服務架構規劃、Docker image 管理、網路與安全設定等。適合想學習如何利用容器技術架設 Web 服務的讀者。"><meta itemprop=datePublished content="2023-11-11T14:28:57+08:00"><meta itemprop=dateModified content="2023-11-11T15:22:30+08:00"><meta itemprop=wordCount content="1370"><meta itemprop=keywords content="Docker,Postgresql,grafana,Ubuntu,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker | 縮網址服務實作記錄 (1) - 基於 Docker 容器技術的網站服務架構實踐"><meta name=twitter:description content="本文紀錄使用 Docker Compose 在 Digital Ocean Ubuntu VPS 上架設縮網址服務的過程,包括環境設定、服務架構規劃、Docker image 管理、網路與安全設定等。適合想學習如何利用容器技術架設 Web 服務的讀者。"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=/css/style.min.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-4HXSCXTZKZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4HXSCXTZKZ",{anonymize_ip:!1})}</script><link href=/css/syntax.min.css rel=stylesheet><link href=/css/copy-to-clipboard.min.css rel=stylesheet></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class="logo logo--mixed"><a class=logo__link href=/ title=伊恩的開發狂想 rel=home><div class="logo__item logo__imagebox"><img class=logo__img alt=logo src=/img/placeholder.png></div><div class="logo__item logo__text"><div class=logo__title>伊恩的開發狂想</div><div class=logo__tagline>在知識大海中漂流的小船，不停追尋屬於自己的秘寶。專注於 .NET、雲端技術、系統架構、開發技巧的道、法、術。</div></div></a></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Docker | 縮網址服務實作記錄 (1) - 基於 Docker 容器技術的網站服務架構實踐</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>伊恩</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-11-11T14:28:57+08:00>2023-11-11</time>
<time class=meta__text datetime=2023-11-11T15:22:30+08:00>(Last Modified: 2023-11-11)</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/%E6%9E%B6%E6%A7%8B/ rel=category>架構</a>, <a class=meta__link href=/categories/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/ rel=category>系列文章</a>, <a class=meta__link href=/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/ rel=category>軟體開發</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#一服務環境評估選擇與服務架構規劃>一、服務環境評估、選擇與服務架構規劃</a><ul><li><a href=#評估與規劃的先決條件>評估與規劃的先決條件</a></li><li><a href=#服務架構圖>服務架構圖</a></li></ul></li><li><a href=#主機設定>主機設定</a><ul><li><a href=#設定防火牆>設定防火牆</a></li><li><a href=#使用者權限設定>使用者權限設定</a></li><li><a href=#docker-確認>Docker 確認</a></li></ul></li><li><a href=#二服務佈署與設定>二、服務佈署與設定</a><ul><li><a href=#docker-image-的-artifact-管理>Docker Image 的 Artifact 管理</a></li><li><a href=#服務佈屬>服務佈屬</a></li></ul></li><li><a href=#補充資料>補充資料</a></li></ul></nav></div></div><div class="content post__content clearfix"><blockquote><p>縮網址服務為 <a href=http://url-ins.com/shorten/>http://url-ins.com/shorten/</a> ，有任何想法或回饋，可以在 <a href=https://www.surveycake.com/s/wgveX>SurveyCake</a> 留下寶貴的意見。(為了維持主機的維運，在頁面內放入 Google Adsense 廣告。)</p></blockquote><blockquote><p>🔖 長話短說 🔖</p><p>設定 Ubuntu 允許 SSH 使用密碼登入時，除了 <code>/etc/ssh/sshd_config</code> 需要調整，也要檢查 Include 其他的 <code>.conf</code> 是否有覆寫的情況。</p></blockquote><p>使用技術、框架與環境設定如下</p><ul><li>網路服務商<ul><li>Domain: <a href=https://tw.godaddy.com/>Godaddy</a></li><li>主機平台: <a href=https://m.do.co/c/254e8cbe525a>Digital Ocean</a></li><li>版控與 Container Registry: <a href=https://gitlab.com>GitLab</a></li></ul></li><li>使用服務:<ul><li>Nginx 1.25.3</li><li>Postgresql 16</li><li>Grafana 10.2</li><li>Loki 2.9.2</li></ul></li><li>使用技術<ul><li>Vue3 / <a href=https://astro.build>Astro</a> 3.3</li><li>.NET 7</li></ul></li></ul><p>使用相關線上工具</p><ul><li><a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhTW">NGINXConfig</a>: Digital Ocean 提供的 Nginx conf 的產生器，可直接使用介面點選後，自動產生對應的 Nginx config。</li></ul><h2 id=一服務環境評估選擇與服務架構規劃>一、服務環境評估、選擇與服務架構規劃</h2><h3 id=評估與規劃的先決條件>評估與規劃的先決條件</h3><ul><li>在初期，維運成本的支出，要盡可能的低。</li><li>使用 Docker 進行服務的佈署與管理。</li><li>服務只對外開放 80/443 PORT，以及 SSH 22 PORT。</li><li>集中收集與分析服務維運時的 LOG。</li></ul><p>在維運成本的考量下，初期使用一台主機來建置整個服務系統，並基於 Container 進行佈署與維運。</p><p>最後選擇 Godaddy + <a href=https://m.do.co/c/254e8cbe525a>Digital Ocean</a>(使用此推薦連結，可獲得 $200 的使用額度) 單一主機建立服務。</p><p>在 Docker Image 的 Artiact 的管理部份，最初的選擇，是直接使用 Digital Ocean 的 <code>Container Registry</code> 。但考量 Free Plan 只能使用一個 Repo，而這個專案有使用至少 2 個 Image。</p><p>後面轉為使用 GitLab 的 Container registry，主要的原因，是因為它 Unlimit Private Container registry。</p><h3 id=服務架構圖>服務架構圖</h3><p><figure><center><img src=images/service-arch.png alt="VPS 內的服務架構"><figcaption>VPS 內的服務架構</figcaption></center></figure></p><h4 id=服務>服務</h4><p>最初是希望有需要的使用服務的應用程式，可以直接調用 API，所以設計是以 API First 的方式，來進行開發規劃。同時，也讓提供一般使用者，可以進行基本的操作。</p><p>因此，這次主要的開發的項目，主要集中在面對使用者的前端頁面呈現，以及 Web API 功能的部份。</p><p>前端頁面選擇使用 Astro + Vue3 這對組合。主要是 Astro 建置出來的靜態網頁，對 SEO 與網頁速度有著不錯效能。Vue3 則是用於使用者互動的部份。(因為目前只對 Vue3 有些許的經驗)</p><p>Web API 的部份，則是使用最熟悉的 .NET Core，順便嘗試 .NET 7 之後的效能與支援的語法。</p><p>資料庫則是選擇使用後起新秀的 Postgresql，最主要的考量，最熟悉的 MS SQL SERVER 的 Lincese 費用，不是一般 Side Project 可以承受。而且後繼轉換為雲端服務商 Serverless RDS 的成本也在可接受範圍。(簡單來說，就是成本考量)</p><p>在監控與維運報警的部份，則是直接選擇使用 Grafana 全套，有一個考量，就是運用 Grafana 支援的 OpenTelemetry 來進一步研究 OpenTelemetry。</p><h4 id=網路規劃>網路規劃</h4><p>在 Digital Ocean 的 VPS 防火牆只開放 80/443/22 這幾個需要的 PORT。</p><p>在主機內，直接使用 Docker netowrk 來進行網段的切分。在這在專案，只有簡單進行以下切分。</p><table><thead><tr><th>Network-name</th><th>說明</th></tr></thead><tbody><tr><td>gateway</td><td>NGINX/WEB 與 Web API 所在的網段。</td></tr><tr><td>backend</td><td>Web API 與 Database 所在的網段。</td></tr><tr><td>ops</td><td>Grafana 相關服務與 Web API 所在的網段。</td></tr></tbody></table><p>目前只有這樣簡單切分網段，後續有機會，會依據 <a href=https://docs.docker.com/engine/security/>Docker security</a> 的說明，進一步進行 security 相關的設定。</p><h2 id=主機設定>主機設定</h2><p>在服務主機的 OS 部份，使用 Ubuntu Ubuntu 22.04.3 LTS。</p><p>有以下的要求設定</p><ul><li>對外只開放 80/443 與 SSH 使用的 22 PORT</li><li>操作只能使用特定帳號，來操作 Docker 的操作。</li></ul><h3 id=設定防火牆>設定防火牆</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 確認目前防火牆狀態</span>
</span></span><span style=display:flex><span>ufw status
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 設定規則</span>
</span></span><span style=display:flex><span>ufw allow 80/tcp
</span></span><span style=display:flex><span>ufw allow 443/tcp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 開啟防火牆</span>
</span></span><span style=display:flex><span>ufw enable
</span></span></code></pre></div><p><figure><center><img src=images/ubuntu-ufw-status.jpeg alt="ufw status"><figcaption>ufw status</figcaption></center></figure></p><h3 id=使用者權限設定>使用者權限設定</h3><p>我們可以使用以下的指令來新增使用者，在這邊以 <code>opser</code> 這個使用者名稱為例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo adduser 新使用者名稱
</span></span><span style=display:flex><span>sudo usermod -aG sudo 新使用者名稱
</span></span><span style=display:flex><span>su - 新使用者名稱
</span></span></code></pre></div><p><figure><center><img src=images/ubuntu-adduser.jpeg alt><figcaption></figcaption></center></figure></p><h4 id=使用密碼驗證-password-authenticaiton>使用密碼驗證 (Password Authenticaiton)</h4><p>若是後續想要使用密碼來進行 SSH 連線，若 <code>sshd_config</code> 內的 <code>PasswordAuthentication</code> 為 <code>no</code>，使用 SSH 登入時，會直接出現 <code>Permission denied (publickey).</code> 錯誤。</p><p>Ditigal Ocean 開立的 Ubuntu 主機，預設是關閉 <code>PasswordAuthentication</code> 的，若要使用密碼認證，需要進行一些設定</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/ssh/sshd_config | grep
</span></span></code></pre></div><p><figure><center><img src=images/ubuntu-user-password-auth-1.jpeg alt="確認 sshd_config 內的設定"><figcaption>確認 sshd_config 內的設定</figcaption></center></figure></p><p>開啟密碼認證的設定，將 <code>PasswordAuthentication</code> 設為 <code>yes</code>。</p><p><figure><center><img src=images/ubuntu-user-password-auth-2.jpeg alt="在調整後，再次確認 sshd_config"><figcaption>在調整後，再次確認 sshd_config</figcaption></center></figure></p><p>重啟 <code>sshd</code> 服務，讓 <code>PasswordAuthentication</code> 變動生效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl restart sshd
</span></span></code></pre></div><p>📢 題外話：改完了設定，但還是無法使用密碼登入！！</p><p>在 <code>/etc/ssh/sshd_config</code> 有一行指令要特別注意，它會在載入 <code>sshd_config</code> 的設定後，再去載入其他的 <code>*.conf</code> 設定值。若出現相同的設定，後者的設定值會覆寫前面。</p><p>在 Digital Ocean 建立的主機，<code>/etc/ssh/</code> 內有一個資料夾 <code>sshd_config.d</code>，其中有一個 <code>50-cloud-init.conf</code> 檔案，會將 <code>PasswordAuthentication</code> 覆寫為 <code>no</code>。</p><p>當我們已經完成調整，嘗試使用 SSH 密碼登入時，還是出現 <code>Permission denied (publickey).</code> 的訊息。記得去檢查是不是這個問題。</p><h4 id=使用-ssh-key-認證>使用 SSH Key 認證</h4><p>若我們不開放密碼認證，只允許新的使用者，只能使用 SSH Key 去進行登入認證。</p><p>在 <a href=https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604>How To Set Up SSH Keys on Ubuntu 16.04 | DigitalOcean</a> 這一篇文章，其實寫的還滿清楚的。</p><p>目前的情境: Ubuntu 主機只開放 <code>root</code> 使用 SSH Key 認證，不開放密碼認證，新使用者無法登入的前提下，進行設定。</p><p>可使用以下的步驟來進行設定。</p><ul><li>使用 <code>ssh-keygen</code> 建立新的公私鑰。</li><li>將 SSH 使用的 Public Key 複制到 Ubuntu 主機。</li><li>建立使用者的 <code>authorized_keys</code> 與對應的 <code>.ssh</code> 訪問權限。</li></ul><p>首先，先產生新使用者 <code>opser</code> 使用的 SSH Key。</p><p><figure><center><img src=images/ssh-keygen-key.jpeg alt="使用 ssh-keygen 產生 public/private key"><figcaption>使用 ssh-keygen 產生 public/private key</figcaption></center></figure></p><p>接著，讓我們把 Public Key 放到 Ubuntu 主機，並進行 <code>authorized_keys</code> 與對應的 <code>.ssh</code> 訪問權限設定。</p><p>在這，我先把建立出來的 Public Key (digitalocean_opser.pub) 使用 <code>SCP</code> 上傳到 Ubuntu 主機的 <code>/</code> 路徑下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 因為我們先登入 root, 所以要切到要調整的使用者帳號 opser 下</span>
</span></span><span style=display:flex><span>su - opser
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 若沒有 .ssh 資料夾，就建立。</span>
</span></span><span style=display:flex><span>mkdir -p ~/.ssh
</span></span><span style=display:flex><span><span style=color:#75715e># 建立 authorized_keys</span>
</span></span><span style=display:flex><span>touch ~/.ssh/authorized_keys
</span></span><span style=display:flex><span><span style=color:#75715e># 設定 .ssh 的讀取權限</span>
</span></span><span style=display:flex><span>chmod -R go<span style=color:#f92672>=</span> ~/.ssh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 把 /digitalocean_opser.pub 的內容放到 /home/opser/.ssh/authorized_keys 內。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 實際操作，請作實際名稱調整</span>
</span></span><span style=display:flex><span>cat /digitalocean_opser.pub &gt;&gt; ~/.ssh/authorized_keys
</span></span></code></pre></div><p><figure><center><img src=images/set-ubuntu-user-ssh-key-1.jpeg alt><figcaption></figcaption></center></figure></p><p><figure><center><img src=images/set-ubuntu-user-ssh-key-2.jpeg alt><figcaption></figcaption></center></figure></p><p>完成上述指令之後就可以順利的使用 opser 以 SSH Key 登入。</p><p><figure><center><img src=images/new-user-ssh-key-success.png alt="使用 opser 順利登入 Ubuntu 主機"><figcaption>使用 opser 順利登入 Ubuntu 主機</figcaption></center></figure></p><h3 id=docker-確認>Docker 確認</h3><p>可以使用 <code>docker --version</code> 來確認目前 Ubuntu 上安裝的 docker 版本。若還沒有安裝，可以參考官方文件
(<a href=https://docs.docker.com/engine/install/ubuntu/>Install Docker Engine on Ubuntu | Docker Docs</a>) 的說明，進行安裝。</p><p>在這邊，採用增加 <code>apt</code> Repository 的方式，來進行 Docker 的安裝。下面簡單說明幾個步驟。</p><h4 id=1-增加-docker-的-apt-repository>1. 增加 Docker 的 apt Repository</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Add Docker&#39;s official GPG key:</span>
</span></span><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install ca-certificates curl gnupg
</span></span><span style=display:flex><span>sudo install -m <span style=color:#ae81ff>0755</span> -d /etc/apt/keyrings
</span></span><span style=display:flex><span>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
</span></span><span style=display:flex><span>sudo chmod a+r /etc/apt/keyrings/docker.gpg
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Add the repository to Apt sources:</span>
</span></span><span style=display:flex><span>echo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  <span style=color:#e6db74>&#34;deb [arch=&#34;</span><span style=color:#66d9ef>$(</span>dpkg --print-architecture<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#34;</span><span style=color:#66d9ef>$(</span>. /etc/os-release <span style=color:#f92672>&amp;&amp;</span> echo <span style=color:#e6db74>&#34;</span>$VERSION_CODENAME<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34; stable&#34;</span> | <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</span></span><span style=display:flex><span>sudo apt-get update
</span></span></code></pre></div><p>在確保使用最新版本的套件前提下，下載 Docker 的 GPG public key，以確保下載的 Docker 是官方的版本。</p><h4 id=2-安裝-docker-相關套件>2. 安裝 Docker 相關套件</h4><p>安装最新版本的 Docker 套件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</span></span></code></pre></div><p>測試是否安裝成功。如果能看到 <code>Hello from Docker!</code> 訊息，表示 Docker 已成功安装。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo docker run hello-world
</span></span></code></pre></div><h4 id=加入-docker-用戶組選項>加入 docker 用戶組(選項)</h4><p>若是後續在執行 <code>docker</code> 指令時，不想要每次都都要輸入 <code>sudo</code> 的話，別忘了在用戶組內，加入 docker 操作權限。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo usermod -aG docker <span style=color:#e6db74>${</span>USER<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 重啟 Docker</span>
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=二服務佈署與設定>二、服務佈署與設定</h2><h3 id=docker-image-的-artifact-管理>Docker Image 的 Artifact 管理</h3><h4 id=docker-login>docker login</h4><p>在把建置出來的 Image Push 到 Container Registry 之前，我們需要先登入要存放 Image 的 Container Registry。</p><pre tabindex=0><code>docker login &lt;container-registry-host&gt;
</code></pre><p>這邊以 Digital Ocean 的 Container Registry(registry.digitalocean.com) 為例。</p><p>只要在 <code>Username</code> 與 <code>Password</code> 輸入正確的認證資料，就可以順利登入。至於認證資料輸入的內容，請查看各 Container Registry 的要求。</p><p>例如 Digital Ocean 的認證資料，就需要先去申請 API Token 後，再把 Token 輸入 Username/Password。</p><p><figure><center><img src=images/docker-login-digitalocean.jpeg alt="docker login DigitalOcean"><figcaption>docker login DigitalOcean</figcaption></center></figure>在成功登入，就可以在允許的權限下，進行 Container Registry 操作。</p><h4 id=docker-push-image>docker push image</h4><p>在 Push 到 Container Registry 之前，來看一下 Docker 官網的<a href=https://docs.docker.com/engine/reference/commandline/push/>說明</a>。</p><p>可以藉由 Push 的指令，將 Image 分享到 Docker Hub 或自建的 Container Registry。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker push <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> NAME:<span style=color:#f92672>[</span>Tag<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>這個有個小細節。</p><p>當我們連到 <a href=https://docs.docker.com/engine/reference/commandline/tag/>docker tag | Docker Docs</a> 進一步查看資訊時，會發現 docker push 的 <code>NAME</code> 的內容格式為 <code>[HOST[:PORT]/]PATH</code>，由 <code>HOST</code>、<code>PORT</code> 與 <code>PATH</code> 三者組成。</p><p>若是沒有指定 <code>HOST</code>，預設指向 Docker Hub 所在的 <code>docker.io</code>。</p><p>這意味著，若是想要把自行產生的 Image 上傳到 Digital Ocean Container Registry。在上傳之前，就必須使用 <code>docker tag</code> 進行名稱的調整，將 Image 名稱加上 <code>HOST</code> 資訊。</p><p>以 Digital Ocean Container Registry 為例，若是要上傳 <code>url-insight/web</code> 到 Digital Ocean Container Registry 的 Repo(url-insight) 之中，就需要執行下述指令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># docker tag &lt;image-name&gt;:&lt;tag&gt; registry.digitalocean.com/&lt;registry-name&gt;/&lt;image-name&gt;:&lt;tag&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker tag url-insight/web:latest registry.digitalocean.com/my-registry/url-insight/web:latest
</span></span></code></pre></div><p>完成更名後，就可以把 Image 上傳到 Digital Ocean Container Registry。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker push registry.digitalocean.com/&lt;registry-name&gt;/&lt;image-name&gt;:&lt;tag&gt;
</span></span></code></pre></div><p>例如，將 <code>url-insight/web</code> 映像推送到 Container Registry：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker push registry.digitalocean.com/my-registry/url-insight/web:latest
</span></span></code></pre></div><p><figure><center><img src=images/cli-push-image-to-digital-ocean.png alt="Push image 到 Digital Ocean Container Registry"><figcaption>Push image 到 Digital Ocean Container Registry</figcaption></center></figure></p><p>完成 Push 後，就可以在 Digital Ocean Container Registry 查到上傳的 Image 記錄。</p><p><figure><center><img src=images/digital-ocean-container-registry-push-result.jpeg alt><figcaption></figcaption></center></figure></p><h4 id=變更使用的-container-registry>變更使用的 Container Registry</h4><p>在完成 <code>uri-insight/web</code> 的 Image 上傳後，繼續上傳 <code>uri-insight/api</code> 的 Docker Image 時，出現 <code>denied: registry contains 1 repositories, limit is 1</code> 錯誤。</p><p><figure><center><img src=images/push-image-denied.png alt="Push Image 到 Digital Ocean 時，被拒絕"><figcaption>Push Image 到 Digital Ocean 時，被拒絕</figcaption></center></figure></p><p>這時，我才發現犯了一個認知的錯誤。</p><p>原本查看 Digital Ocean 的 Registry 的免費方案時，以為 Digitial Coean 的 Starter plan 的 1 Repo，指的是 Project level 的 Repository。</p><p><figure><center><img src=images/digital-ocean-container-registry-payment-plan.jpeg alt><figcaption></figcaption></center></figure></p><p>想說可以將實作的服務，<code>uri-insight/web</code> 與 <code>uri-insight/api</code> 兩個 Image，都上傳到同一個 Repo。</p><p>在實作使用時，才發現它指的是 Docker Image Repository，只要不同的 NAME，就會視為不同的 REPO。</p><p>所以 push 第二個 Docker Image 時，才會出現了 <code>denied: registry contains 1 repositories, limit is 1</code> 錯誤。</p><p><figure><center><img src=images/push-image-denied.png alt="Push Image 到 Digital Ocean 時，被拒絕"><figcaption>Push Image 到 Digital Ocean 時，被拒絕</figcaption></center></figure></p><p>剛好，使用的版控的 Gitlab 平台，也有提供 Container registry，而且，在官方的 <a href=https://docs.gitlab.com/ee/user/packages/container_registry/>GitLab Container Registry 說明文件</a>中提到，它們提供的 Private Container Registry 沒有數量限制。</p><p>所以決定移到 GitLab 這個 Unlimit Private Container Registry。</p><p><figure><center><img src=images/gitlab-container-registry-entry.jpeg alt="Container Registry 進入位置"><figcaption>Container Registry 進入位置</figcaption></center></figure></p><p><figure><center><img src=images/gitlab-container-registory.jpeg alt="GitLab 的 Container Registry 畫面"><figcaption>GitLab 的 Container Registry 畫面</figcaption></center></figure></p><p>題外話，在 Container Registry 的呈現畫面，個人比較喜歡 Digital Ocean 的呈現方式</p><p><figure><center><img src=images/digitial-ocean-container-registry.jpeg alt="Digital Ocean 的 Container Registry 畫面"><figcaption>Digital Ocean 的 Container Registry 畫面</figcaption></center></figure></p><h3 id=服務佈屬>服務佈屬</h3><p>在服務佈署的部份，在還沒有建立 CI/CD 流程之前。使用 <code>scp</code> 的指令，透過 SSH，將服務相關的 <code>*.yml</code> 與 <code>nginx.conf</code> 等檔案傳輸到服務主機。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 單一檔案</span>
</span></span><span style=display:flex><span>scp <span style=color:#f92672>[</span>source-host:<span style=color:#f92672>]</span>&lt;來源檔案&gt; <span style=color:#f92672>[</span>帳號@target-host<span style=color:#f92672>]</span>:&lt;目地檔案&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 資料夾</span>
</span></span><span style=display:flex><span>scp -r <span style=color:#f92672>[</span>source-host:<span style=color:#f92672>]</span>&lt;來源資料夾&gt; <span style=color:#f92672>[</span>帳號@target-host<span style=color:#f92672>]</span>:&lt;目地資料夾&gt;
</span></span></code></pre></div><p>後續使用 <code>docker compose</code> 來建立 Container 時，需要從 Container Registry 下載所需要的 Docker Image。所以不要忘記先進行 <code>docker login</code> 的動作。</p><p>在 url-insight 的服務，<code>docker compose</code> 相關的 <code>.yml</code> 的設定與說明如下。</p><h4 id=網段設定>網段設定</h4><p>若想要使用 <code>docker compose</code> 來統一管理 Container 時，<code>docker compose</code> 會自動建立對應該 <code>.yml</code> 設定檔內 network。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo docker compose up -p proj up -d
</span></span></code></pre></div><p>在上述的例子，因為指定 <code>docker compose</code> 啟動一個名為 proj 的專案，所以它在背後，會自行建立一個名為 <code>proj-network</code> 的 Docker network。</p><p>但在規劃中，希望啟用的 Container 分別歸屬於 <code>gateway</code>、<code>backend</code>、<code>ops</code> 這三個網段。所以需要進行以下的動作。</p><p>首先，手動建立使用的 network</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker network create ops
</span></span><span style=display:flex><span>docker network create backend
</span></span><span style=display:flex><span>docker network create gateway
</span></span></code></pre></div><p>接著，在 <code>docker compose</code> 使用的 <code>*.yml</code> 內，指定使用的網路下方，加入 <code>external: true</code> 指示，docker compose 就不會自建網址，而是使用外部已存在網路。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>network</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>my-network</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><h4 id=a-web-gateway-作為站台與入口的-gateway-設定>A. Web-Gateway: 作為站台與入口的 gateway 設定</h4><p>使用 Nginx 作為反向代理，並設定 <code>nginx.conf</code>，讓所有的請求依 Domain 與路徑，指向 Astro/Vue 建立的靜態網站，或是 WebAPI 服務。</p><p>若是對 Nginx 組態不熟悉，也可以使用 Digital Ocean 提供的 NGINX Conig 設定工具 (<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhTW">NGINXConfig</a>) 或 ChatGPT/Claude.ai 來協助設定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>registry.gitlab.com/url-insight/url-insight/web:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>80</span>:<span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./nginx.conf:/etc/nginx/nginx.conf:ro</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      -  <span style=color:#ae81ff>gateway-web</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><p>yaml 檔內使用的 <code>url-insight/web</code> 是以 Nginx 為基底，將 Astro/Vue 的靜態站台一併封裝。</p><p>重點在於 Mount <code>nginx.conf</code> 設定與指定使用外部已建立的網路 <code>gateway</code>。</p><h4 id=b-backend-提供-webapi-服務>B. Backend: 提供 Webapi 服務</h4><p>Backend 網段，主要是 .NET 7 開發的 Web API(<code>url-insight/api</code>) 與 PostgreSQL 資訊所在的網段。</p><p>而 yaml 檔內的關注點如下。</p><ul><li>使用 <code>expose</code> 來宣告 container 可使用的 port, 提供同 docker-network 的其他 container 連入。但無法從外面連入 Container。</li><li>webapi 服務，同時身處 3 個 docker-network，其目的與 Container 間的資訊傳輸與 DNS 解析相關。</li></ul><p>順帶一提，若 Container 內的應用程式，若是想要連到其他的 Container, 建議建立 docker-network，再配合 docker DNS 解析，簡單快速的達成目的。</p><p>在下述的 yaml 檔啟動的服務，在 webapi container 內的程式，可以透過 <code>postgres:5432</code> 的設定，順利訪問資料庫。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>webapi</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>registry.gitlab.com/url-insight/url-insight/api:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>expose</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>443</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>ASPNETCORE_ENVIRONMENT=Production</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>ConnectionStrings:${DB_ConnctionString}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>backend</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>gateway</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>ops</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>postgres</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres:16</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>POSTGRES_USER=${PSG_USER}$</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>POSTGRES_PASSWORD=${PSG_PWD}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>expose</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>5432</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>postgres-data:/var/lib/postgresql/data</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>backend</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>postgres-data</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ops</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><blockquote><p>📢 題外話</p><p>在 Linux 在指定連線字串時，務必大小寫相同。因為個人習慣在 windows 上開發，沒注意到這個細節。
在佈置在 Ubuntu 與執行 Container，花了一些時間在排除這個問題。</p></blockquote><h4 id=c-ops-用於收集與監控系統資訊>C. Ops: 用於收集與監控系統資訊</h4><p>Ops 網段，主要是負責管理所有與維運相關服務的網路。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>grafana-ops</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>loki</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>grafana/loki:2.9.2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;3100:3100&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>command</span>: -<span style=color:#ae81ff>config.file=/etc/loki/local-config.yaml</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>grafana</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>grafana</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>GF_PATHS_PROVISIONING=/etc/grafana/provisioning</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>GF_AUTH_ANONYMOUS_ENABLED=true</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>GF_AUTH_ANONYMOUS_ORG_ROLE=Admin</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>entrypoint</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>sh</span>
</span></span><span style=display:flex><span>      - -<span style=color:#ae81ff>euc</span>
</span></span><span style=display:flex><span>      - |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        mkdir -p /etc/grafana/provisioning/datasources
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        cat &lt;&lt;EOF &gt; /etc/grafana/provisioning/datasources/ds.yaml
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        apiVersion: 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        datasources:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        - name: Loki
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          type: loki
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          access: proxy
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          orgId: 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          url: http://loki:3100
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          basicAuth: false
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          isDefault: true
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          version: 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          editable: false
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        /run.sh</span>        
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>grafana/grafana:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;3000:3000&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>grafana</span>
</span></span></code></pre></div><p>但因為在規劃時，不希望對外開放於 Internet，但又需要讓維運人員可以藉由 Grafana 來查看目前系統狀態。</p><p>所以使用 SSH Tunnel 的方式，讓維運人員可以直接查看 Grafana。</p><p>簡單附上使用的語法，若要詳細用法，可參考補充資料。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ssh -L &lt;-port&gt;:&lt;remote-host&gt;:&lt;remote-port&gt; &lt;user&gt;@&lt;remote-host&gt;
</span></span></code></pre></div><h2 id=補充資料>補充資料</h2><p>▶ 站內文章</p><p>▶ 外部文章</p><ul><li><a href=https://philipzheng.gitbook.io/docker_practice/install/ubuntu>Ubuntu - 《Docker —— 從入門到實踐 ­》正體中文版</a></li><li><a href=https://footmark.com.tw/news/linux/ubuntu/ubuntu-server-ufw/>Ubuntu Server 20.04.1 預設 UFW 防火牆 Firewall 設定規則詳解和教學</a></li><li><a href=https://yu-jack.github.io/2019/01/08/ssh-tunnel/>關於 SSH Tunnel 連線 (SSH Proxy, SSH Port Forwarding) - 技術雜記 Technology Notes - Jack Yu | 傑克</a></li><li><a href=https://johnliu55.tw/ssh-tunnel.html>SSH Tunneling (Port Forwarding) 詳解 · John Engineering Stuff</a></li><li><a href=https://www.tecmint.com/ssh-permission-denied-publickey/>How to Fix SSH Permission Denied (Public key) Error</a></li></ul><p>▶ 參考連結</p><ul><li><a href=https://terryl.in/zh/best-pricing-vps/>2023 VPS 主機價格評比：Linode, Vultr, DigitalOcean, OVH - TerryL</a></li><li><a href=https://progressbar.tw/posts/131>學習 VPS 的重要性與各大 Linux VPS 比較與推薦 (Linode, DigitalOcean, Vultr, AWS Lightsail)</a></li></ul></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><a class=tag href=/tags/docker/ rel=tag>Docker</a>
<a class=tag href=/tags/postgresql/ rel=tag>Postgresql</a>
<a class=tag href=/tags/grafana/ rel=tag>grafana</a>
<a class=tag href=/tags/ubuntu/ rel=tag>Ubuntu</a></ul></div></footer><hr><div><p>文章內容均為個人學習記錄、心得與認知，若任何謬誤或建議，歡迎直接留言討論，一同成長。</p></div><iframe class=LikeCoin src="https://button.like.co/in/embed/wosilee/button?referrer=https%3a%2f%2feandev.com%2fpost%2fseries%2fside-project%2fshorten-1-build-service-base-on-container%2f" height=200 width=100% frameborder=0></iframe>
<script src=/js/copy-code-clipboard.min.js></script></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/develop/ef-core-cli-note/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>EF Core | CLI Tools 操作筆記</p></a></div></nav><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//eanblog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 伊恩軟體技術學習與分享.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div></body></html>