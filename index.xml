<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>伊恩的開發狂想</title><link>https://eanlee.github.io/</link><description>Recent content on 伊恩的開發狂想</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Thu, 04 Aug 2022 06:22:43 +0000</lastBuildDate><atom:link href="https://eanlee.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>淺聊單元測試的撰寫</title><link>https://eanlee.github.io/post/test/taking_ut/</link><pubDate>Thu, 04 Aug 2022 06:22:43 +0000</pubDate><guid>https://eanlee.github.io/post/test/taking_ut/</guid><description>&lt;p>近年來，在業界各位前輩的推展下，越來越多人知道單元測試，並且開始撰寫單元測試。&lt;/p>
&lt;p>但有些撰寫單元測試過程中，遇到有些經常被人詢問議題，或是自己撰寫過程所遇到困惑點，在這分享個人的觀點。&lt;/p>
&lt;ul>
&lt;li>運用單元測試，讓工具可以自動化一再反覆驗證核心業務邏輯或是高風險的邏輯，以確保業務邏輯或規則的正確性。&lt;/li>
&lt;li>對於沒有測試保護的程式，使用已知的使用情境案例，從修改部份進行最大範圍的框選，運用粗顆粒的測試案例，讓修改部份，有個基本的保護。&lt;/li>
&lt;li>對於要注入眾多物件的類別，應考量適常的類別功能切開。減少單元測試的複雜性，並提升程式的維護性。&lt;/li>
&lt;/ul></description></item><item><title>淺談 YAML 格式</title><link>https://eanlee.github.io/post/series/build_automated_deploy/yaml/</link><pubDate>Fri, 29 Jul 2022 06:12:44 +0000</pubDate><guid>https://eanlee.github.io/post/series/build_automated_deploy/yaml/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://eanlee.github.io/post/series/build_automated_deploy/foreword/#額外補充">從零開始建立自動化發佈的流水線&lt;/a> 額外補充&lt;/p>
&lt;/blockquote>
&lt;p>當在進行 CI/CD 工具的 pipelines 或軟體組態設定時，可能都有機會看到 YAML 格式撰寫的設定檔。下面簡單的聊聊 YAML 撰寫規則。&lt;/p></description></item><item><title>程式碼版控 - 觀念與 Git 簡述</title><link>https://eanlee.github.io/post/series/build_automated_deploy/version_control/</link><pubDate>Fri, 29 Jul 2022 10:14:10 +0800</pubDate><guid>https://eanlee.github.io/post/series/build_automated_deploy/version_control/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://eanlee.github.io/post/series/build_automated_deploy/foreword/#版控篇">從零開始建立自動化發佈的流水線&lt;/a> 版控篇&lt;/p>
&lt;/blockquote>
&lt;p>當軟體持續發展，難免出現客制化需求，或是要求針對特定版本進行功能異動，尤其是團隊協作的情況下，有沒有那種方式可以提供有效的統整現有的程式碼，讓協作開發人員，都可以取得最新的開發版本。也可以快速的調出過往的程式異動版本，以便追查問題或調整。&lt;/p></description></item><item><title>聊聊架構 - 系統負載、分流與限制理論</title><link>https://eanlee.github.io/post/architecture/talking_system_loading_and_limit/</link><pubDate>Tue, 26 Jul 2022 09:35:47 +0000</pubDate><guid>https://eanlee.github.io/post/architecture/talking_system_loading_and_limit/</guid><description>&lt;p>無論技術決策或解決方案的選擇，經常因為現實環境造成的種種限制條件，導致無法直接使用最優解。需要基於限制條件下，進行相對應的妥協與方案的調整。&lt;/p>
&lt;p>做為系統開發或維運人員，當系統遇到麻煩或困難或瓶頸時，所提出的解決方案或作法，需將先天的限制列入評估。試著在有限的的資源，想辦法得到最大的效率或收益。為此，需要試著找出造成麻煩的瓶頸，加以分析，最終得出解除瓶頸的方案。&lt;/p>
&lt;p>若觀察的視角過小或過於局部，所找到的系統瓶頸，從整個系統視角評估，有時會發現，原先認為的瓶頸，並不是真正的瓶頸問題。為此，可以運用限制理論去找出問題環節，配合 80/20 法則找出影響力最大的點，然後處理它。&lt;/p></description></item><item><title>系統架構演進與 AWS 雲端服務結合(1) - 內部系統快速驗證</title><link>https://eanlee.github.io/post/architecture/evolutionandcloudplatform/01_mvp_vaification/</link><pubDate>Fri, 24 Jun 2022 01:17:18 +0000</pubDate><guid>https://eanlee.github.io/post/architecture/evolutionandcloudplatform/01_mvp_vaification/</guid><description>&lt;p>假設新創的網路服務提供商，隨著業務的發展，提供服務的軟體系統，從最初的簡易架構，依據面臨的挑戰與需求，不停調整擴充系統架構。&lt;/p>
&lt;p>系統若建立在雲端，隨著系統架構的演進的同時，所對應雲端服務供應商的服務。本文章僅為個人學習與理解雲端服務的手札，有任何更好的建議都歡迎告知。&lt;/p></description></item><item><title>聊聊名詞 - 單點故障 Single point of failure, SPOF</title><link>https://eanlee.github.io/post/nouns/spof/</link><pubDate>Thu, 23 Jun 2022 03:25:10 +0000</pubDate><guid>https://eanlee.github.io/post/nouns/spof/</guid><description>&lt;p>單點故障(Single point of failure, SPOF)，指的是系統上的某一個物理節點故障，而導致整個系統無法運作的現象。&lt;/p>
&lt;p>當進行系統風險評估時，必需將單點故障造成的影響，列入評估的範圍。依單點故障發生，會造成服務中止或系統全面性故障，&lt;a href="https://eanlee.github.io/post/nouns/%E8%81%8A%E8%81%8A%E5%90%8D%E8%A9%9E-%E5%86%97%E9%A4%98-redundancy/">冗餘機制&lt;/a>的設定就必定列入考量。&lt;/p></description></item><item><title>踏入 CI/CD 的世界 - 觀念篇</title><link>https://eanlee.github.io/post/series/build_automated_deploy/cicd_concept/</link><pubDate>Wed, 22 Jun 2022 16:00:19 +0000</pubDate><guid>https://eanlee.github.io/post/series/build_automated_deploy/cicd_concept/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://eanlee.github.io/post/series/build_automated_deploy/foreword/#持續整合">從零開始建立自動化發佈的流水線&lt;/a> 持續整合篇&lt;/p>
&lt;/blockquote>
&lt;p>當程式碼已經進入版控系統後，就會想要有個服務可以自動去建置、驗證 source code 的完整性與安全性，最好還可以自行部屬。而 CI/CD 就是為了滿足這個希望，而誕生出來的機制。&lt;/p></description></item><item><title>簡述程式碼品質與優化方向</title><link>https://eanlee.github.io/post/series/optimize_code_quality/coding_suggest/</link><pubDate>Tue, 21 Jun 2022 15:06:43 +0000</pubDate><guid>https://eanlee.github.io/post/series/optimize_code_quality/coding_suggest/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://eanlee.github.io/post/series/optimize_code_quality/foreword/#基礎篇">持續優化程式碼品質&lt;/a> 基礎篇&lt;/p>
&lt;/blockquote>
&lt;p>在開發時，為了快速或是避免麻煩，可能會用簡單的代號，例如 &lt;code>aa&lt;/code> 這種名稱，來暫時做為變數的名稱。這無可厚非，但是&amp;hellip;假若在完成該功能後，未能進行程式的整理。&lt;/p>
&lt;p>也許在三個月後的某一天，程式有需求變動，不管是要修改自己開發的程式，還是要維護前人遺留下來的軟體。在一番苦戰，好不容易找到要修改變動的程式區塊。&lt;/p>
&lt;p>看著各種無意義的命名、複雜且混亂的程式邏輯，只能苦苦的思考，為什麼當初會這樣寫？這個變數是什麼意義？動作背後的用意？邊改寫程式，邊幹譙當初寫下這段程式的人。&lt;/p></description></item><item><title>從零開始建立自動化發佈的流水線(持續搬移中)</title><link>https://eanlee.github.io/post/series/build_automated_deploy/foreword/</link><pubDate>Mon, 20 Jun 2022 06:58:08 +0000</pubDate><guid>https://eanlee.github.io/post/series/build_automated_deploy/foreword/</guid><description>&lt;blockquote>
&lt;p>將 &lt;a href="https://ithelp.ithome.com.tw/users/20107551/ironman/1906">2019 iT 邦幫忙鐵人賽&lt;/a> 的文章搬遷到此，同時有些內部可能已經過時，在搬移的過程中，會重新針對內容加以整理與補充。&lt;/p>
&lt;/blockquote>
&lt;p>以故事的方式，隨著故事的發展，逐一建構一條從版控到發佈的自動化作業，會逐一帶出四個階段的主題。&lt;/p>
&lt;ul>
&lt;li>程式碼版本控管&lt;/li>
&lt;li>CI server 的架設&lt;/li>
&lt;li>自動發佈最新版本的軟體&lt;/li>
&lt;li>Container&lt;/li>
&lt;/ul></description></item><item><title>持續優化程式碼品質(持續搬移中)</title><link>https://eanlee.github.io/post/series/optimize_code_quality/foreword/</link><pubDate>Mon, 20 Jun 2022 06:12:48 +0000</pubDate><guid>https://eanlee.github.io/post/series/optimize_code_quality/foreword/</guid><description>&lt;blockquote>
&lt;p>當初參與 &lt;a href="https://ithelp.ithome.com.tw/users/20107551/ironman/1430">2018 iT 邦幫忙鐵人賽&lt;/a>，挑戰三十天連續不間斷發文失敗。將當初的文章搬遷到此，同時對文章內容，進行整理與補完欠缺的內容。&lt;/p>
&lt;/blockquote>
&lt;p>在持續開發軟體的生涯中，經手或協同開發的過程中。常常發現各種小問題累積，最後導致軟體的維護，變成如同惡夢的地獄，其實只要在開發中間，利用一些技巧，就可以程式碼更容易閱讚與維護。&lt;/p></description></item><item><title>開發雜談 - 對於系統架構的多維度思考能力</title><link>https://eanlee.github.io/post/experiences/multidimensional_thinking/</link><pubDate>Sat, 18 Jun 2022 17:10:57 +0000</pubDate><guid>https://eanlee.github.io/post/experiences/multidimensional_thinking/</guid><description>&lt;p>在研究某個軟體的系統架構，發現一個值得探討的問題。&lt;/p>
&lt;p>當設計系統架構時，使用何種的視界去分析與設計，會得到不一樣的設計結果，但結果是否為當下最佳的解決方案？&lt;/p></description></item><item><title>Queue 佇列的概念</title><link>https://eanlee.github.io/post/series/messagequeue/host/queue/</link><pubDate>Tue, 14 Jun 2022 07:46:41 +0000</pubDate><guid>https://eanlee.github.io/post/series/messagequeue/host/queue/</guid><description>&lt;p>個人認為佇列(Queue)的本質，就是做為資料載體的暫存與緩衝區，同時，它具備 &lt;strong>先進先出(First In First Out, FIFO)&lt;/strong> 的特性。&lt;/p>
&lt;p>在演算法中，有些演算法使用 Queue 做為操作記錄資料的載體，例如針對二元樹的尋訪(Traversal)，廣度優先搜尋(Breadth First Search)，都是活用 Queue FIFO 的特性。&lt;/p>
&lt;p>有時，資料本身的數量有限，但同時有多個對象需要取得資料。使用 Queue 來控制資料的處理速度，或是調配資源的的方式，作為資料配置最佳化的方式之一。&lt;/p>
&lt;p>經常運用於跨執行緒、跨行程、跨系統之中的通訊使用。在這種場域下，產生資料與處理資料的兩方，處理的速度不一相同。借由 Queue 的暫存緩衝與 FIFO 特性，便於採用非同步的處理方式。&lt;/p></description></item><item><title>從零開始土炮 MQ (持續搬移中)</title><link>https://eanlee.github.io/post/series/messagequeue/foreword/</link><pubDate>Tue, 14 Jun 2022 07:12:18 +0000</pubDate><guid>https://eanlee.github.io/post/series/messagequeue/foreword/</guid><description>&lt;blockquote>
&lt;p>將原本參與 &lt;a href="https://ithelp.ithome.com.tw/users/20107551/ironman/2172">第 11 屆 iThome 鐵人賽&lt;/a> 的文章，再加以整理與補充。&lt;/p>
&lt;/blockquote>
&lt;p>近幾年參與開發的軟體之中，大量使用到佇列(Queue)的技術與觀念。從同步與非同步存取 Queue；利用 Queue 與 Dispatch 組合，進行備援處理的機制；大量資料的接收與轉發等等。另一方面，微服務與服務解耦的議題，訊息佇列（Message Queue）的使用頻率也逐年提升。&lt;/p>
&lt;p>以傻子的精神，土幹一個 Message Queue，利用這個過程，好好的深入了解 Message Queue 的概念。&lt;/p></description></item><item><title>開發雜談 - API Server 有非預期的請求的原因釐清</title><link>https://eanlee.github.io/post/experiences/unexpected_request/</link><pubDate>Fri, 10 Jun 2022 04:00:00 +0000</pubDate><guid>https://eanlee.github.io/post/experiences/unexpected_request/</guid><description>&lt;p>某天 Infra 人員發現還沒對外正式開放的環境，API Server 內的硬碟空間，在短短半個月內，被 IIS Log 吃掉近 20GB 的空間，協同開發人員一同釐清這現象的原因。&lt;/p></description></item><item><title>聊聊名詞 - 冗餘 Redundancy</title><link>https://eanlee.github.io/post/nouns/%E8%81%8A%E8%81%8A%E5%90%8D%E8%A9%9E-%E5%86%97%E9%A4%98-redundancy/</link><pubDate>Thu, 09 Jun 2022 09:15:15 +0000</pubDate><guid>https://eanlee.github.io/post/nouns/%E8%81%8A%E8%81%8A%E5%90%8D%E8%A9%9E-%E5%86%97%E9%A4%98-redundancy/</guid><description>&lt;p>冗餘(Redundancy)是指為提昇系統的穩定性與可靠性，刻意配置重複的零件或機能。此動作主要是為避免單一環節失效，對系統的衝擊。&lt;/p></description></item><item><title>淺談 HTTPS 與 SSL/TLS 的關係</title><link>https://eanlee.github.io/post/security/talking_https_and_ssl/</link><pubDate>Mon, 23 May 2022 23:52:24 +0000</pubDate><guid>https://eanlee.github.io/post/security/talking_https_and_ssl/</guid><description>&lt;p>在開始之前，先提一下 OSI，它是由國際標準化組織(ISO)針對開放式網路架構所制定的電腦互連標準，全名是開放式通訊系統互連參考模型（Open System Interconnection Reference Model, OSI），簡稱 OSI 模型。依網路通訊的運作，依不同的傳輸模式、定義的規範與標準，從實體到抽象，將劃分為七層。&lt;/p></description></item><item><title>從消除遊戲學到的專案管理二三事</title><link>https://eanlee.github.io/post/projectmanagement/concepts_of_project_management_from_elimination_games/</link><pubDate>Thu, 28 Apr 2022 03:50:27 +0000</pubDate><guid>https://eanlee.github.io/post/projectmanagement/concepts_of_project_management_from_elimination_games/</guid><description>&lt;p>在休閒時間遊玩的消除遊戲，無意中發現消除遊戲中，每一關的過關方式，都可以與專案管理有關。&lt;/p>
&lt;p>每一關都像一個全新的專案，在專案進行的過程中，一定會對確認目標，確定要交付的內容，可以使用的資源，是否有那些難點是會影響專案進行下去的要素。&lt;/p></description></item><item><title>亂聊壓力測試到底要做什麼?</title><link>https://eanlee.github.io/post/test/talking_stress_test/</link><pubDate>Sun, 03 Apr 2022 07:30:13 +0000</pubDate><guid>https://eanlee.github.io/post/test/talking_stress_test/</guid><description>&lt;p>壓力測試必須是有特定目的的前提下去動作的，不同的目的會影響到你的測試做法以及測試系統架構。&lt;/p>
&lt;p>壓力測試是將系統效能，加以量化的動作，只有量化才有依據，調整或決定後續的處理方式。無論是增加機器、設定監控警告的水位，或是找出品系統瓶頸加以改善優化，&lt;/p></description></item><item><title>軟體開發需求釐清</title><link>https://eanlee.github.io/post/software/requirements_clarify/</link><pubDate>Sun, 02 Jan 2022 19:10:58 +0000</pubDate><guid>https://eanlee.github.io/post/software/requirements_clarify/</guid><description>&lt;p>當接到一個新的需求或新的任務，對需求/任務的內容、牽扯到人、事、物，絕大多的情況，或許明白部份的情況，但無法全盤明確情況。&lt;/p>
&lt;p>從一開始不了解需求，因為無知所產生的不安與焦慮。會隨著專案的進行，越來越來了解詳細的內容，就會變得平穩。但若中途發現有些部份的問題沒有考量到、或是誤解部份的需求，但交付期限將近，這時的感覺一定很差。&lt;/p>
&lt;p>而且發生非預期的意外或誤解需求時，立即盤點影響範圍時，卻發現待解決的事項，無法在預定時程內完成，只好宣告失敗，再次爭取新的資源與時間。或是使用加班技能，交付一個自己都不滿意，但勉強可以符合需求的結果。&lt;/p>
&lt;p>隨著專案的進行，從一開始不了解需求，因為無知所產生的不安與焦慮。會隨著專案的進行，越來越來了解詳細的內容，就會變得平穩。往往在專案結束後的回顧時，不禁會想到有些情況，若能提早知道，就可以避免無效的作工。&lt;/p>
&lt;p>雖然，無法精確知道專案開發內，所有可能會遭遇到的難題或卡點，卻可以藉由啟動前的盤點與分析，嘗試看見全貌，提先鎖定需求或作法不明確的範圍，提早知道可能遇到的瓶頸，限定問題發生範圍。&lt;/p>
&lt;p>以下分享的部份，是個人針對新專案需求的處理方式，若有更好的方式，也歡迎分享。&lt;/p></description></item><item><title>[Fluent Assertions] Object graph comparison</title><link>https://eanlee.github.io/post/test/fluentassertionscollectionscompare/</link><pubDate>Thu, 11 Feb 2021 14:00:22 +0000</pubDate><guid>https://eanlee.github.io/post/test/fluentassertionscollectionscompare/</guid><description>&lt;p>日前在撰寫單元測試時，發生測試失敗，使用 &lt;code>Should().BeEquivalentTo(expected)&lt;/code> 進行物件比對，已確認 &lt;code>待測物件&lt;/code> 與 &lt;code>期望物件&lt;/code> 內的資料相同，但卻出現 &lt;code>be it misses&lt;/code> 造成的測試結果&lt;code>失敗&lt;/code>。所使用的 FlunentAssertion Nuget 版本為 &lt;code>4.13.1&lt;/code> 。&lt;/p></description></item><item><title>年度文章總覽</title><link>https://eanlee.github.io/archives/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://eanlee.github.io/archives/</guid><description>年度文章總覽</description></item></channel></rss>