<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>伊恩的開發狂想</title><link>https://eanlee.github.io/</link><description>Recent content on 伊恩的開發狂想</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Tue, 14 Jun 2022 07:46:41 +0000</lastBuildDate><atom:link href="https://eanlee.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>從零開始土炮 MQ - Queue</title><link>https://eanlee.github.io/post/series/messagequeue/host/queue/</link><pubDate>Tue, 14 Jun 2022 07:46:41 +0000</pubDate><guid>https://eanlee.github.io/post/series/messagequeue/host/queue/</guid><description>&lt;p>個人認為佇列(Queue)的本質，就是做為資料載體的暫存與緩衝區，同時，它具備 &lt;strong>先進先出(First In First Out, FIFO)&lt;/strong> 的特性。&lt;/p>
&lt;p>在演算法中，有些演算法使用 Queue 做為操作記錄資料的載體，例如針對二元樹的尋訪(Traversal)，廣度優先搜尋(Breadth First Search)，都是活用 Queue FIFO 的特性。&lt;/p>
&lt;p>有時，資料本身的數量有限，但同時有多個對象需要取得資料。使用 Queue 來控制資料的處理速度，或是調配資源的的方式，作為資料配置最佳化的方式之一。&lt;/p>
&lt;p>經常運用於跨執行緒、跨行程、跨系統之中的通訊使用。在這種場域下，產生資料與處理資料的兩方，處理的速度不一相同。借由 Queue 的暫存緩衝與 FIFO 特性，便於採用非同步的處理方式。&lt;/p></description></item><item><title>從零開始土炮 MQ</title><link>https://eanlee.github.io/post/series/messagequeue/foreword/</link><pubDate>Tue, 14 Jun 2022 07:12:18 +0000</pubDate><guid>https://eanlee.github.io/post/series/messagequeue/foreword/</guid><description>&lt;p>將原本參與 iT 幫幫忙三十天鐵人賽的文章，再加以整理與補充。&lt;/p>
&lt;p>近幾年參與開發的軟體之中，大量使用到佇列(Queue)的技術與觀念。從同步與非同步存取 Queue；利用 Queue 與 Dispatch 組合，進行備援處理的機制；大量資料的接收與轉發等等。另一方面，微服務與服務解耦的議題，訊息佇列（Message Queue）的使用頻率也逐年提升。&lt;/p>
&lt;p>以傻子的精神，土幹一個 Message Queue，利用這個過程，好好的深入了解 Message Queue 的概念。&lt;/p></description></item><item><title>開發雜談 - API Server 有非預期的請求的原因釐清</title><link>https://eanlee.github.io/post/experiences/unexpected_request/</link><pubDate>Fri, 10 Jun 2022 04:00:00 +0000</pubDate><guid>https://eanlee.github.io/post/experiences/unexpected_request/</guid><description>&lt;p>某天 Infra 人員發現還沒對外正式開放的環境，API Server 內的硬碟空間，在短短半個月內，被 IIS Log 吃掉近 20GB 的空間，協同開發人員一同釐清這現象的原因。&lt;/p></description></item><item><title>聊聊名詞 - 冗餘 Redundancy</title><link>https://eanlee.github.io/post/nouns/%E8%81%8A%E8%81%8A%E5%90%8D%E8%A9%9E-%E5%86%97%E9%A4%98-redundancy/</link><pubDate>Thu, 09 Jun 2022 09:15:15 +0000</pubDate><guid>https://eanlee.github.io/post/nouns/%E8%81%8A%E8%81%8A%E5%90%8D%E8%A9%9E-%E5%86%97%E9%A4%98-redundancy/</guid><description>&lt;p>冗餘(Redundancy)是指為提昇系統的穩定性與可靠性，刻意配置重複的零件或機能。此動作主要是為避免單一環節失效，對系統的衝擊。&lt;/p></description></item><item><title>淺談 HTTPS 與 SSL/TLS 的關係</title><link>https://eanlee.github.io/post/security/talking_https_and_ssl/</link><pubDate>Mon, 23 May 2022 23:52:24 +0000</pubDate><guid>https://eanlee.github.io/post/security/talking_https_and_ssl/</guid><description>&lt;p>在開始之前，先提一下 OSI，它是由國際標準化組織(ISO)針對開放式網路架構所制定的電腦互連標準，全名是開放式通訊系統互連參考模型（Open System Interconnection Reference Model, OSI），簡稱 OSI 模型。依網路通訊的運作，依不同的傳輸模式、定義的規範與標準，從實體到抽象，將劃分為七層。&lt;/p></description></item><item><title>從消除遊戲學到的專案管理二三事</title><link>https://eanlee.github.io/post/projectmanagement/concepts_of_project_management_from_elimination_games/</link><pubDate>Thu, 28 Apr 2022 03:50:27 +0000</pubDate><guid>https://eanlee.github.io/post/projectmanagement/concepts_of_project_management_from_elimination_games/</guid><description>&lt;p>在休閒時間遊玩的消除遊戲，無意中發現消除遊戲中，每一關的過關方式，都可以與專案管理有關。&lt;/p>
&lt;p>每一關都像一個全新的專案，在專案進行的過程中，一定會對確認目標，確定要交付的內容，可以使用的資源，是否有那些難點是會影響專案進行下去的要素。&lt;/p></description></item><item><title>亂聊壓力測試到底要做什麼?</title><link>https://eanlee.github.io/post/test/talking_stress_test/</link><pubDate>Sun, 03 Apr 2022 07:30:13 +0000</pubDate><guid>https://eanlee.github.io/post/test/talking_stress_test/</guid><description>&lt;p>壓力測試必須是有特定目的的前提下去動作的，不同的目的會影響到你的測試做法以及測試系統架構。&lt;/p>
&lt;p>壓力測試是將系統效能，加以量化的動作，只有量化才有依據，調整或決定後續的處理方式。無論是增加機器、設定監控警告的水位，或是找出品系統瓶頸加以改善優化，&lt;/p></description></item><item><title>軟體開發需求釐清</title><link>https://eanlee.github.io/post/software/requirements_clarify/</link><pubDate>Sun, 02 Jan 2022 19:10:58 +0000</pubDate><guid>https://eanlee.github.io/post/software/requirements_clarify/</guid><description>&lt;p>當接到一個新的需求或新的任務，對需求/任務的內容、牽扯到人、事、物，絕大多的情況，或許明白部份的情況，但無法全盤明確情況。&lt;/p>
&lt;p>從一開始不了解需求，因為無知所產生的不安與焦慮。會隨著專案的進行，越來越來了解詳細的內容，就會變得平穩。但若中途發現有些部份的問題沒有考量到、或是誤解部份的需求，但交付期限將近，這時的感覺一定很差。&lt;/p>
&lt;p>而且發生非預期的意外或誤解需求時，立即盤點影響範圍時，卻發現待解決的事項，無法在預定時程內完成，只好宣告失敗，再次爭取新的資源與時間。或是使用加班技能，交付一個自己都不滿意，但勉強可以符合需求的結果。&lt;/p>
&lt;p>隨著專案的進行，從一開始不了解需求，因為無知所產生的不安與焦慮。會隨著專案的進行，越來越來了解詳細的內容，就會變得平穩。往往在專案結束後的回顧時，不禁會想到有些情況，若能提早知道，就可以避免無效的作工。&lt;/p>
&lt;p>雖然，無法精確知道專案開發內，所有可能會遭遇到的難題或卡點，卻可以藉由啟動前的盤點與分析，嘗試看見全貌，提先鎖定需求或作法不明確的範圍，提早知道可能遇到的瓶頸，限定問題發生範圍。&lt;/p>
&lt;p>以下分享的部份，是個人針對新專案需求的處理方式，若有更好的方式，也歡迎分享。&lt;/p></description></item><item><title>[Fluent Assertions] Object graph comparison</title><link>https://eanlee.github.io/post/test/fluentassertionscollectionscompare/</link><pubDate>Thu, 11 Feb 2021 14:00:22 +0000</pubDate><guid>https://eanlee.github.io/post/test/fluentassertionscollectionscompare/</guid><description>&lt;p>日前在撰寫單元測試時，發生測試失敗，使用 &lt;code>Should().BeEquivalentTo(expected)&lt;/code> 進行物件比對，已確認 &lt;code>待測物件&lt;/code> 與 &lt;code>期望物件&lt;/code> 內的資料相同，但卻出現 &lt;code>be it misses&lt;/code> 造成的測試結果&lt;code>失敗&lt;/code>。所使用的 FlunentAssertion Nuget 版本為 &lt;code>4.13.1&lt;/code> 。&lt;/p></description></item></channel></rss>